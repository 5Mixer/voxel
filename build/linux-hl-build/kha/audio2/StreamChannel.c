// Generated by HLC 4.1.3 (HL v4)
#define HLC_BOOT
#include <hlc.h>
#include <kha/audio2/StreamChannel.h>
#include <kha/arrays/Float32ArrayPrivate.h>
#include <hl/natives.h>
#include <haxe/io/Bytes.h>
#include <haxe/io/BytesDataImpl.h>
extern hl_type t$haxe_io_BytesDataImpl;
void haxe_io_BytesDataImpl_new(haxe__io__BytesDataImpl,vbyte*,int);

void kha_audio2_StreamChannel_nextSamples(kha__audio2__StreamChannel r0,kha__arrays__Float32ArrayPrivate r1,int r2,int r3) {
	bool r5, r13;
	float r11;
	vbyte *r9, *r12;
	int r6, r7, r8, r10;
	r5 = r0->paused;
	if( !r5 ) goto label$90bbcc2_1_15;
	r6 = 0;
	r7 = r2;
	label$90bbcc2_1_4:
	if( r6 >= r7 ) goto label$90bbcc2_1_14;
	r8 = r6;
	++r6;
	if( r1 == NULL ) hl_null_access();
	r9 = r1->self;
	r10 = 0;
	r11 = (float)r10;
	hl_kore_float32array_set(r9,r8,r11);
	goto label$90bbcc2_1_4;
	label$90bbcc2_1_14:
	return;
	label$90bbcc2_1_15:
	r9 = r0->_vorbis;
	if( r1 == NULL ) hl_null_access();
	r12 = r1->self;
	r5 = r0->loop;
	r13 = r0->atend;
	r5 = hl_kore_sound_next_vorbis_samples(r9,r12,r2,r5,r13);
	r0->atend = r5;
	return;
}

void kha_audio2_StreamChannel_play(kha__audio2__StreamChannel r0) {
	bool r1;
	r1 = false;
	r0->paused = r1;
	return;
}

void kha_audio2_StreamChannel_pause(kha__audio2__StreamChannel r0) {
	bool r1;
	r1 = true;
	r0->paused = r1;
	return;
}

void kha_audio2_StreamChannel_stop(kha__audio2__StreamChannel r0) {
	bool r1;
	r1 = true;
	r0->atend = r1;
	return;
}

double kha_audio2_StreamChannel_get_length(kha__audio2__StreamChannel r0) {
	double r3;
	vbyte *r2;
	int r1;
	r2 = r0->_vorbis;
	r1 = hl_kore_sound_vorbis_get_length(r2);
	r3 = (double)r1;
	return r3;
}

double kha_audio2_StreamChannel_get_position(kha__audio2__StreamChannel r0) {
	double r3;
	vbyte *r2;
	int r1;
	r2 = r0->_vorbis;
	r1 = hl_kore_sound_vorbis_get_position(r2);
	r3 = (double)r1;
	return r3;
}

double kha_audio2_StreamChannel_set_position(kha__audio2__StreamChannel r0,double r1) {
	return r1;
}

double kha_audio2_StreamChannel_get_volume(kha__audio2__StreamChannel r0) {
	double r1;
	r1 = r0->myVolume;
	return r1;
}

double kha_audio2_StreamChannel_set_volume(kha__audio2__StreamChannel r0,double r1) {
	r0->myVolume = r1;
	return r1;
}

bool kha_audio2_StreamChannel_get_finished(kha__audio2__StreamChannel r0) {
	bool r1;
	r1 = r0->atend;
	return r1;
}

void kha_audio2_StreamChannel_new(kha__audio2__StreamChannel r0,haxe__io__Bytes r1,bool r2) {
	bool r3;
	haxe__io__BytesDataImpl r5;
	double r4;
	int r7;
	vbyte *r6;
	r3 = false;
	r0->paused = r3;
	r3 = false;
	r0->atend = r3;
	r4 = 1.;
	r0->myVolume = r4;
	r0->loop = r2;
	r5 = (haxe__io__BytesDataImpl)hl_alloc_obj(&t$haxe_io_BytesDataImpl);
	if( r1 == NULL ) hl_null_access();
	r6 = r1->b;
	r7 = r1->length;
	haxe_io_BytesDataImpl_new(r5,r6,r7);
	r6 = r5->bytes;
	r7 = r1->length;
	r6 = hl_kore_sound_init_vorbis(r6,r7);
	r0->_vorbis = r6;
	return;
}

