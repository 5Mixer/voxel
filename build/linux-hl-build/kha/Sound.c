// Generated by HLC 4.1.3 (HL v4)
#define HLC_BOOT
#include <hlc.h>
#include <kha/Sound.h>
#include <haxe/io/BytesOutput.h>
#include <kha/audio2/ogg/vorbis/data/Header.h>
#include <kha/audio2/Audio.h>
extern hl_type t$haxe_io_BytesOutput;
void haxe_io_BytesOutput_new(haxe__io__BytesOutput);
#include <haxe/io/Output.h>
kha__audio2__ogg__vorbis__data__Header kha_audio2_ogg_vorbis_Reader_readAll(haxe__io__Bytes,haxe__io__Output,bool*);
haxe__io__Bytes haxe_io_BytesOutput_getBytes(haxe__io__BytesOutput);
extern kha__audio2__$Audio g$_kha_audio2_Audio;
extern hl_type t$kha_arrays_Float32ArrayPrivate;
void kha_arrays_Float32ArrayPrivate_new(kha__arrays__Float32ArrayPrivate);
#include <hl/natives.h>
double haxe_io_Bytes_getFloat(haxe__io__Bytes,int);

void kha_Sound_uncompress(kha__Sound r0,vclosure* r1) {
	kha__audio2__$Audio r15;
	bool *r8;
	bool r7;
	haxe__io__Bytes r6, r11;
	kha__audio2__ogg__vorbis__data__Header r5;
	haxe__io__BytesOutput r4;
	float r23;
	kha__arrays__Float32ArrayPrivate r3, r17;
	double r9, r12, r16;
	vbyte *r19;
	int r10, r13, r14, r18, r20, r21, r22;
	r3 = r0->uncompressedData;
	if( !r3 ) goto label$f74786f_1_5;
	if( r1 == NULL ) hl_null_access();
	r1->hasValue ? ((void (*)(vdynamic*))r1->fun)((vdynamic*)r1->value) : ((void (*)(void))r1->fun)();
	return;
	label$f74786f_1_5:
	r4 = (haxe__io__BytesOutput)hl_alloc_obj(&t$haxe_io_BytesOutput);
	haxe_io_BytesOutput_new(r4);
	r6 = r0->compressedData;
	r7 = true;
	r8 = &r7;
	r5 = kha_audio2_ogg_vorbis_Reader_readAll(r6,((haxe__io__Output)r4),r8);
	r6 = haxe_io_BytesOutput_getBytes(r4);
	if( r6 == NULL ) hl_null_access();
	r10 = r6->length;
	r9 = (double)r10;
	r12 = 4.;
	r9 = r9 / r12;
	r10 = (int)r9;
	if( r5 == NULL ) hl_null_access();
	r13 = r5->channel;
	r14 = 1;
	if( r13 != r14 ) goto label$f74786f_1_69;
	r12 = (double)r10;
	r15 = (kha__audio2__$Audio)g$_kha_audio2_Audio;
	r13 = r15->samplesPerSecond;
	r16 = (double)r13;
	r12 = r12 / r16;
	r0->length = r12;
	r14 = 2;
	r13 = r10 * r14;
	r3 = (kha__arrays__Float32ArrayPrivate)hl_alloc_obj(&t$kha_arrays_Float32ArrayPrivate);
	kha_arrays_Float32ArrayPrivate_new(r3);
	r3->length = r13;
	r18 = 0;
	if( r18 >= r13 ) goto label$f74786f_1_37;
	r19 = hl_kore_float32array_alloc(r13);
	r3->self = r19;
	label$f74786f_1_37:
	r0->uncompressedData = r3;
	r14 = 0;
	r18 = r10;
	label$f74786f_1_40:
	if( r14 >= r18 ) goto label$f74786f_1_68;
	r20 = r14;
	++r14;
	r17 = r0->uncompressedData;
	if( r6 == NULL ) hl_null_access();
	r22 = 4;
	r21 = r20 * r22;
	r12 = haxe_io_Bytes_getFloat(r6,r21);
	r23 = (float)r12;
	if( r17 == NULL ) hl_null_access();
	r19 = r17->self;
	r22 = 2;
	r21 = r20 * r22;
	hl_kore_float32array_set(r19,r21,r23);
	r17 = r0->uncompressedData;
	r22 = 4;
	r21 = r20 * r22;
	r12 = haxe_io_Bytes_getFloat(r6,r21);
	r23 = (float)r12;
	if( r17 == NULL ) hl_null_access();
	r19 = r17->self;
	r22 = 2;
	r21 = r20 * r22;
	r22 = 1;
	r21 = r21 + r22;
	hl_kore_float32array_set(r19,r21,r23);
	goto label$f74786f_1_40;
	label$f74786f_1_68:
	goto label$f74786f_1_101;
	label$f74786f_1_69:
	r12 = (double)r10;
	r16 = 2.;
	r12 = r12 / r16;
	r15 = (kha__audio2__$Audio)g$_kha_audio2_Audio;
	r13 = r15->samplesPerSecond;
	r16 = (double)r13;
	r12 = r12 / r16;
	r0->length = r12;
	r3 = (kha__arrays__Float32ArrayPrivate)hl_alloc_obj(&t$kha_arrays_Float32ArrayPrivate);
	kha_arrays_Float32ArrayPrivate_new(r3);
	r3->length = r10;
	r14 = 0;
	if( r14 >= r10 ) goto label$f74786f_1_84;
	r19 = hl_kore_float32array_alloc(r10);
	r3->self = r19;
	label$f74786f_1_84:
	r0->uncompressedData = r3;
	r13 = 0;
	r14 = r10;
	label$f74786f_1_87:
	if( r13 >= r14 ) goto label$f74786f_1_101;
	r18 = r13;
	++r13;
	r17 = r0->uncompressedData;
	if( r6 == NULL ) hl_null_access();
	r21 = 4;
	r20 = r18 * r21;
	r12 = haxe_io_Bytes_getFloat(r6,r20);
	r23 = (float)r12;
	if( r17 == NULL ) hl_null_access();
	r19 = r17->self;
	hl_kore_float32array_set(r19,r18,r23);
	goto label$f74786f_1_87;
	label$f74786f_1_101:
	if( r5 == NULL ) hl_null_access();
	r13 = r5->channel;
	r0->channels = r13;
	r13 = r5->sampleRate;
	r0->sampleRate = r13;
	r11 = NULL;
	r0->compressedData = r11;
	if( r1 == NULL ) hl_null_access();
	r1->hasValue ? ((void (*)(vdynamic*))r1->fun)((vdynamic*)r1->value) : ((void (*)(void))r1->fun)();
	return;
}

void kha_Sound_unload(kha__Sound r0) {
	haxe__io__Bytes r1;
	kha__arrays__Float32ArrayPrivate r2;
	r1 = NULL;
	r0->compressedData = r1;
	r2 = NULL;
	r0->uncompressedData = r2;
	return;
}

void kha_Sound_new(kha__Sound r0) {
	double r2;
	int r1;
	r1 = 0;
	r0->sampleRate = r1;
	r1 = 0;
	r0->channels = r1;
	r2 = 0.;
	r0->length = r2;
	return;
}

