// Generated by Haxe 4.1.3
#include <hxcpp.h>

#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_ReaderErrorType
#include <hxinc/kha/audio2/ogg/vorbis/data/ReaderErrorType.h>
#endif
namespace kha{
namespace audio2{
namespace ogg{
namespace vorbis{
namespace data{

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::BAD_PACKET_TYPE;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::CANT_FIND_LAST_PAGE;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::CONTINUED_PACKET_FLAG_INVALID;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::FEATURE_NOT_SUPPORTED;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::FILE_OPEN_FAILURE;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::INCORRECT_STREAM_SERIAL_NUMBER;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::INVALID_API_MIXING;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::INVALID_FIRST_PAGE;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::INVALID_SETUP;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::INVALID_STREAM;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::INVALID_STREAM_STRUCTURE_VERSION;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::MISSING_CAPTURE_PATTERN;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::NEED_MORE_DATA;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::OTHER;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::OUTOFMEM;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::SEEK_FAILED;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::SEEK_INVALID;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::SEEK_WITHOUT_LENGTH;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::TOO_MANY_CHANNELS;

::kha::audio2::ogg::vorbis::data::ReaderErrorType ReaderErrorType_obj::UNEXPECTED_EOF;

bool ReaderErrorType_obj::__GetStatic(const ::String &inName, ::Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	if (inName==HX_("BAD_PACKET_TYPE",37,65,8a,89)) { outValue = ReaderErrorType_obj::BAD_PACKET_TYPE; return true; }
	if (inName==HX_("CANT_FIND_LAST_PAGE",0d,60,a4,66)) { outValue = ReaderErrorType_obj::CANT_FIND_LAST_PAGE; return true; }
	if (inName==HX_("CONTINUED_PACKET_FLAG_INVALID",d9,2f,6e,7b)) { outValue = ReaderErrorType_obj::CONTINUED_PACKET_FLAG_INVALID; return true; }
	if (inName==HX_("FEATURE_NOT_SUPPORTED",d9,c5,59,6d)) { outValue = ReaderErrorType_obj::FEATURE_NOT_SUPPORTED; return true; }
	if (inName==HX_("FILE_OPEN_FAILURE",58,e2,fb,aa)) { outValue = ReaderErrorType_obj::FILE_OPEN_FAILURE; return true; }
	if (inName==HX_("INCORRECT_STREAM_SERIAL_NUMBER",6f,d0,09,81)) { outValue = ReaderErrorType_obj::INCORRECT_STREAM_SERIAL_NUMBER; return true; }
	if (inName==HX_("INVALID_API_MIXING",d3,5c,e6,63)) { outValue = ReaderErrorType_obj::INVALID_API_MIXING; return true; }
	if (inName==HX_("INVALID_FIRST_PAGE",c6,c3,85,e2)) { outValue = ReaderErrorType_obj::INVALID_FIRST_PAGE; return true; }
	if (inName==HX_("INVALID_SETUP",b5,17,9e,f8)) { outValue = ReaderErrorType_obj::INVALID_SETUP; return true; }
	if (inName==HX_("INVALID_STREAM",28,bc,5a,33)) { outValue = ReaderErrorType_obj::INVALID_STREAM; return true; }
	if (inName==HX_("INVALID_STREAM_STRUCTURE_VERSION",75,2e,4f,be)) { outValue = ReaderErrorType_obj::INVALID_STREAM_STRUCTURE_VERSION; return true; }
	if (inName==HX_("MISSING_CAPTURE_PATTERN",de,ef,15,71)) { outValue = ReaderErrorType_obj::MISSING_CAPTURE_PATTERN; return true; }
	if (inName==HX_("NEED_MORE_DATA",eb,b5,e3,4e)) { outValue = ReaderErrorType_obj::NEED_MORE_DATA; return true; }
	if (inName==HX_("OTHER",b0,9e,64,b4)) { outValue = ReaderErrorType_obj::OTHER; return true; }
	if (inName==HX_("OUTOFMEM",10,62,53,b6)) { outValue = ReaderErrorType_obj::OUTOFMEM; return true; }
	if (inName==HX_("SEEK_FAILED",e4,54,00,42)) { outValue = ReaderErrorType_obj::SEEK_FAILED; return true; }
	if (inName==HX_("SEEK_INVALID",d0,8d,a3,a2)) { outValue = ReaderErrorType_obj::SEEK_INVALID; return true; }
	if (inName==HX_("SEEK_WITHOUT_LENGTH",84,c3,3b,4c)) { outValue = ReaderErrorType_obj::SEEK_WITHOUT_LENGTH; return true; }
	if (inName==HX_("TOO_MANY_CHANNELS",e5,f6,08,7e)) { outValue = ReaderErrorType_obj::TOO_MANY_CHANNELS; return true; }
	if (inName==HX_("UNEXPECTED_EOF",ee,2b,b5,75)) { outValue = ReaderErrorType_obj::UNEXPECTED_EOF; return true; }
	return super::__GetStatic(inName, outValue, inCallProp);
}

HX_DEFINE_CREATE_ENUM(ReaderErrorType_obj)

int ReaderErrorType_obj::__FindIndex(::String inName)
{
	if (inName==HX_("BAD_PACKET_TYPE",37,65,8a,89)) return 16;
	if (inName==HX_("CANT_FIND_LAST_PAGE",0d,60,a4,66)) return 17;
	if (inName==HX_("CONTINUED_PACKET_FLAG_INVALID",d9,2f,6e,7b)) return 13;
	if (inName==HX_("FEATURE_NOT_SUPPORTED",d9,c5,59,6d)) return 3;
	if (inName==HX_("FILE_OPEN_FAILURE",58,e2,fb,aa)) return 5;
	if (inName==HX_("INCORRECT_STREAM_SERIAL_NUMBER",6f,d0,09,81)) return 14;
	if (inName==HX_("INVALID_API_MIXING",d3,5c,e6,63)) return 1;
	if (inName==HX_("INVALID_FIRST_PAGE",c6,c3,85,e2)) return 15;
	if (inName==HX_("INVALID_SETUP",b5,17,9e,f8)) return 9;
	if (inName==HX_("INVALID_STREAM",28,bc,5a,33)) return 10;
	if (inName==HX_("INVALID_STREAM_STRUCTURE_VERSION",75,2e,4f,be)) return 12;
	if (inName==HX_("MISSING_CAPTURE_PATTERN",de,ef,15,71)) return 11;
	if (inName==HX_("NEED_MORE_DATA",eb,b5,e3,4e)) return 0;
	if (inName==HX_("OTHER",b0,9e,64,b4)) return 19;
	if (inName==HX_("OUTOFMEM",10,62,53,b6)) return 2;
	if (inName==HX_("SEEK_FAILED",e4,54,00,42)) return 18;
	if (inName==HX_("SEEK_INVALID",d0,8d,a3,a2)) return 8;
	if (inName==HX_("SEEK_WITHOUT_LENGTH",84,c3,3b,4c)) return 6;
	if (inName==HX_("TOO_MANY_CHANNELS",e5,f6,08,7e)) return 4;
	if (inName==HX_("UNEXPECTED_EOF",ee,2b,b5,75)) return 7;
	return super::__FindIndex(inName);
}

int ReaderErrorType_obj::__FindArgCount(::String inName)
{
	if (inName==HX_("BAD_PACKET_TYPE",37,65,8a,89)) return 0;
	if (inName==HX_("CANT_FIND_LAST_PAGE",0d,60,a4,66)) return 0;
	if (inName==HX_("CONTINUED_PACKET_FLAG_INVALID",d9,2f,6e,7b)) return 0;
	if (inName==HX_("FEATURE_NOT_SUPPORTED",d9,c5,59,6d)) return 0;
	if (inName==HX_("FILE_OPEN_FAILURE",58,e2,fb,aa)) return 0;
	if (inName==HX_("INCORRECT_STREAM_SERIAL_NUMBER",6f,d0,09,81)) return 0;
	if (inName==HX_("INVALID_API_MIXING",d3,5c,e6,63)) return 0;
	if (inName==HX_("INVALID_FIRST_PAGE",c6,c3,85,e2)) return 0;
	if (inName==HX_("INVALID_SETUP",b5,17,9e,f8)) return 0;
	if (inName==HX_("INVALID_STREAM",28,bc,5a,33)) return 0;
	if (inName==HX_("INVALID_STREAM_STRUCTURE_VERSION",75,2e,4f,be)) return 0;
	if (inName==HX_("MISSING_CAPTURE_PATTERN",de,ef,15,71)) return 0;
	if (inName==HX_("NEED_MORE_DATA",eb,b5,e3,4e)) return 0;
	if (inName==HX_("OTHER",b0,9e,64,b4)) return 0;
	if (inName==HX_("OUTOFMEM",10,62,53,b6)) return 0;
	if (inName==HX_("SEEK_FAILED",e4,54,00,42)) return 0;
	if (inName==HX_("SEEK_INVALID",d0,8d,a3,a2)) return 0;
	if (inName==HX_("SEEK_WITHOUT_LENGTH",84,c3,3b,4c)) return 0;
	if (inName==HX_("TOO_MANY_CHANNELS",e5,f6,08,7e)) return 0;
	if (inName==HX_("UNEXPECTED_EOF",ee,2b,b5,75)) return 0;
	return super::__FindArgCount(inName);
}

::hx::Val ReaderErrorType_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	if (inName==HX_("BAD_PACKET_TYPE",37,65,8a,89)) return BAD_PACKET_TYPE;
	if (inName==HX_("CANT_FIND_LAST_PAGE",0d,60,a4,66)) return CANT_FIND_LAST_PAGE;
	if (inName==HX_("CONTINUED_PACKET_FLAG_INVALID",d9,2f,6e,7b)) return CONTINUED_PACKET_FLAG_INVALID;
	if (inName==HX_("FEATURE_NOT_SUPPORTED",d9,c5,59,6d)) return FEATURE_NOT_SUPPORTED;
	if (inName==HX_("FILE_OPEN_FAILURE",58,e2,fb,aa)) return FILE_OPEN_FAILURE;
	if (inName==HX_("INCORRECT_STREAM_SERIAL_NUMBER",6f,d0,09,81)) return INCORRECT_STREAM_SERIAL_NUMBER;
	if (inName==HX_("INVALID_API_MIXING",d3,5c,e6,63)) return INVALID_API_MIXING;
	if (inName==HX_("INVALID_FIRST_PAGE",c6,c3,85,e2)) return INVALID_FIRST_PAGE;
	if (inName==HX_("INVALID_SETUP",b5,17,9e,f8)) return INVALID_SETUP;
	if (inName==HX_("INVALID_STREAM",28,bc,5a,33)) return INVALID_STREAM;
	if (inName==HX_("INVALID_STREAM_STRUCTURE_VERSION",75,2e,4f,be)) return INVALID_STREAM_STRUCTURE_VERSION;
	if (inName==HX_("MISSING_CAPTURE_PATTERN",de,ef,15,71)) return MISSING_CAPTURE_PATTERN;
	if (inName==HX_("NEED_MORE_DATA",eb,b5,e3,4e)) return NEED_MORE_DATA;
	if (inName==HX_("OTHER",b0,9e,64,b4)) return OTHER;
	if (inName==HX_("OUTOFMEM",10,62,53,b6)) return OUTOFMEM;
	if (inName==HX_("SEEK_FAILED",e4,54,00,42)) return SEEK_FAILED;
	if (inName==HX_("SEEK_INVALID",d0,8d,a3,a2)) return SEEK_INVALID;
	if (inName==HX_("SEEK_WITHOUT_LENGTH",84,c3,3b,4c)) return SEEK_WITHOUT_LENGTH;
	if (inName==HX_("TOO_MANY_CHANNELS",e5,f6,08,7e)) return TOO_MANY_CHANNELS;
	if (inName==HX_("UNEXPECTED_EOF",ee,2b,b5,75)) return UNEXPECTED_EOF;
	return super::__Field(inName,inCallProp);
}

static ::String ReaderErrorType_obj_sStaticFields[] = {
	HX_("NEED_MORE_DATA",eb,b5,e3,4e),
	HX_("INVALID_API_MIXING",d3,5c,e6,63),
	HX_("OUTOFMEM",10,62,53,b6),
	HX_("FEATURE_NOT_SUPPORTED",d9,c5,59,6d),
	HX_("TOO_MANY_CHANNELS",e5,f6,08,7e),
	HX_("FILE_OPEN_FAILURE",58,e2,fb,aa),
	HX_("SEEK_WITHOUT_LENGTH",84,c3,3b,4c),
	HX_("UNEXPECTED_EOF",ee,2b,b5,75),
	HX_("SEEK_INVALID",d0,8d,a3,a2),
	HX_("INVALID_SETUP",b5,17,9e,f8),
	HX_("INVALID_STREAM",28,bc,5a,33),
	HX_("MISSING_CAPTURE_PATTERN",de,ef,15,71),
	HX_("INVALID_STREAM_STRUCTURE_VERSION",75,2e,4f,be),
	HX_("CONTINUED_PACKET_FLAG_INVALID",d9,2f,6e,7b),
	HX_("INCORRECT_STREAM_SERIAL_NUMBER",6f,d0,09,81),
	HX_("INVALID_FIRST_PAGE",c6,c3,85,e2),
	HX_("BAD_PACKET_TYPE",37,65,8a,89),
	HX_("CANT_FIND_LAST_PAGE",0d,60,a4,66),
	HX_("SEEK_FAILED",e4,54,00,42),
	HX_("OTHER",b0,9e,64,b4),
	::String(null())
};

::hx::Class ReaderErrorType_obj::__mClass;

Dynamic __Create_ReaderErrorType_obj() { return new ReaderErrorType_obj; }

void ReaderErrorType_obj::__register()
{

::hx::Static(__mClass) = ::hx::_hx_RegisterClass(HX_("kha.audio2.ogg.vorbis.data.ReaderErrorType",0f,f0,fb,45), ::hx::TCanCast< ReaderErrorType_obj >,ReaderErrorType_obj_sStaticFields,0,
	&__Create_ReaderErrorType_obj, &__Create,
	&super::__SGetClass(), &CreateReaderErrorType_obj, 0
#ifdef HXCPP_VISIT_ALLOCS
    , 0
#endif
#ifdef HXCPP_SCRIPTABLE
    , 0
#endif
);
	__mClass->mGetStaticField = &ReaderErrorType_obj::__GetStatic;
}

void ReaderErrorType_obj::__boot()
{
BAD_PACKET_TYPE = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("BAD_PACKET_TYPE",37,65,8a,89),16);
CANT_FIND_LAST_PAGE = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("CANT_FIND_LAST_PAGE",0d,60,a4,66),17);
CONTINUED_PACKET_FLAG_INVALID = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("CONTINUED_PACKET_FLAG_INVALID",d9,2f,6e,7b),13);
FEATURE_NOT_SUPPORTED = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("FEATURE_NOT_SUPPORTED",d9,c5,59,6d),3);
FILE_OPEN_FAILURE = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("FILE_OPEN_FAILURE",58,e2,fb,aa),5);
INCORRECT_STREAM_SERIAL_NUMBER = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("INCORRECT_STREAM_SERIAL_NUMBER",6f,d0,09,81),14);
INVALID_API_MIXING = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("INVALID_API_MIXING",d3,5c,e6,63),1);
INVALID_FIRST_PAGE = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("INVALID_FIRST_PAGE",c6,c3,85,e2),15);
INVALID_SETUP = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("INVALID_SETUP",b5,17,9e,f8),9);
INVALID_STREAM = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("INVALID_STREAM",28,bc,5a,33),10);
INVALID_STREAM_STRUCTURE_VERSION = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("INVALID_STREAM_STRUCTURE_VERSION",75,2e,4f,be),12);
MISSING_CAPTURE_PATTERN = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("MISSING_CAPTURE_PATTERN",de,ef,15,71),11);
NEED_MORE_DATA = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("NEED_MORE_DATA",eb,b5,e3,4e),0);
OTHER = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("OTHER",b0,9e,64,b4),19);
OUTOFMEM = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("OUTOFMEM",10,62,53,b6),2);
SEEK_FAILED = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("SEEK_FAILED",e4,54,00,42),18);
SEEK_INVALID = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("SEEK_INVALID",d0,8d,a3,a2),8);
SEEK_WITHOUT_LENGTH = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("SEEK_WITHOUT_LENGTH",84,c3,3b,4c),6);
TOO_MANY_CHANNELS = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("TOO_MANY_CHANNELS",e5,f6,08,7e),4);
UNEXPECTED_EOF = ::hx::CreateConstEnum< ReaderErrorType_obj >(HX_("UNEXPECTED_EOF",ee,2b,b5,75),7);
}


} // end namespace kha
} // end namespace audio2
} // end namespace ogg
} // end namespace vorbis
} // end namespace data
