// Generated by Haxe 4.1.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <hxinc/Std.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <hxinc/haxe/Exception.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_VorbisDecodeState
#include <hxinc/kha/audio2/ogg/vorbis/VorbisDecodeState.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_VorbisTools
#include <hxinc/kha/audio2/ogg/vorbis/VorbisTools.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Codebook
#include <hxinc/kha/audio2/ogg/vorbis/data/Codebook.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_ReaderError
#include <hxinc/kha/audio2/ogg/vorbis/data/ReaderError.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_ReaderErrorType
#include <hxinc/kha/audio2/ogg/vorbis/data/ReaderErrorType.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0f8046c382d51ee6_34_new,"kha.audio2.ogg.vorbis.data.Codebook","new",0x6d842e98,"kha.audio2.ogg.vorbis.data.Codebook.new","kha/audio2/ogg/vorbis/data/Codebook.hx",34,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_189_addEntry,"kha.audio2.ogg.vorbis.data.Codebook","addEntry",0x9e9ab559,"kha.audio2.ogg.vorbis.data.Codebook.addEntry","kha/audio2/ogg/vorbis/data/Codebook.hx",189,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_200_includeInSort,"kha.audio2.ogg.vorbis.data.Codebook","includeInSort",0x5c2fda63,"kha.audio2.ogg.vorbis.data.Codebook.includeInSort","kha/audio2/ogg/vorbis/data/Codebook.hx",200,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_214_computeCodewords,"kha.audio2.ogg.vorbis.data.Codebook","computeCodewords",0x179c0b6d,"kha.audio2.ogg.vorbis.data.Codebook.computeCodewords","kha/audio2/ogg/vorbis/data/Codebook.hx",214,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_284_computeSortedHuffman,"kha.audio2.ogg.vorbis.data.Codebook","computeSortedHuffman",0x642a2241,"kha.audio2.ogg.vorbis.data.Codebook.computeSortedHuffman","kha/audio2/ogg/vorbis/data/Codebook.hx",284,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_341_computeAcceleratedHuffman,"kha.audio2.ogg.vorbis.data.Codebook","computeAcceleratedHuffman",0x486d1295,"kha.audio2.ogg.vorbis.data.Codebook.computeAcceleratedHuffman","kha/audio2/ogg/vorbis/data/Codebook.hx",341,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_367_codebookDecode,"kha.audio2.ogg.vorbis.data.Codebook","codebookDecode",0xd5fd826c,"kha.audio2.ogg.vorbis.data.Codebook.codebookDecode","kha/audio2/ogg/vorbis/data/Codebook.hx",367,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_415_codebookDecodeStep,"kha.audio2.ogg.vorbis.data.Codebook","codebookDecodeStep",0x96623bd8,"kha.audio2.ogg.vorbis.data.Codebook.codebookDecodeStep","kha/audio2/ogg/vorbis/data/Codebook.hx",415,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_459_decodeStart,"kha.audio2.ogg.vorbis.data.Codebook","decodeStart",0x32b2568c,"kha.audio2.ogg.vorbis.data.Codebook.decodeStart","kha/audio2/ogg/vorbis/data/Codebook.hx",459,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_483_decodeDeinterleaveRepeat,"kha.audio2.ogg.vorbis.data.Codebook","decodeDeinterleaveRepeat",0x5171272d,"kha.audio2.ogg.vorbis.data.Codebook.decodeDeinterleaveRepeat","kha/audio2/ogg/vorbis/data/Codebook.hx",483,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_574_residueDecode,"kha.audio2.ogg.vorbis.data.Codebook","residueDecode",0xf3c1a811,"kha.audio2.ogg.vorbis.data.Codebook.residueDecode","kha/audio2/ogg/vorbis/data/Codebook.hx",574,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_37_read,"kha.audio2.ogg.vorbis.data.Codebook","read",0x68c95e1e,"kha.audio2.ogg.vorbis.data.Codebook.read","kha/audio2/ogg/vorbis/data/Codebook.hx",37,0xa03d0d77)
static const int _hx_array_data_ee7b42a6_43[] = {
	(int)0,(int)1,(int)2,(int)2,(int)3,(int)3,(int)3,(int)3,(int)4,(int)4,(int)4,(int)4,(int)4,(int)4,(int)4,(int)4,
};
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_15_boot,"kha.audio2.ogg.vorbis.data.Codebook","boot",0x5e3d96fa,"kha.audio2.ogg.vorbis.data.Codebook.boot","kha/audio2/ogg/vorbis/data/Codebook.hx",15,0xa03d0d77)
HX_LOCAL_STACK_FRAME(_hx_pos_0f8046c382d51ee6_480_boot,"kha.audio2.ogg.vorbis.data.Codebook","boot",0x5e3d96fa,"kha.audio2.ogg.vorbis.data.Codebook.boot","kha/audio2/ogg/vorbis/data/Codebook.hx",480,0xa03d0d77)
namespace kha{
namespace audio2{
namespace ogg{
namespace vorbis{
namespace data{

void Codebook_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_34_new)
            	}

Dynamic Codebook_obj::__CreateEmpty() { return new Codebook_obj; }

void *Codebook_obj::_hx_vtable = 0;

Dynamic Codebook_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Codebook_obj > _hx_result = new Codebook_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Codebook_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x42b572ca;
}

void Codebook_obj::addEntry(int huffCode,int symbol,int count,int len,::Array< int > values){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_189_addEntry)
HXDLIN( 189)		if (!(this->sparse)) {
HXLINE( 190)			this->codewords->__unsafe_set(symbol,huffCode);
            		}
            		else {
HXLINE( 192)			this->codewords->__unsafe_set(count,huffCode);
HXLINE( 193)			this->codewordLengths->__unsafe_set(count,len);
HXLINE( 194)			values->__unsafe_set(count,symbol);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Codebook_obj,addEntry,(void))

bool Codebook_obj::includeInSort(int len){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_200_includeInSort)
HXDLIN( 200)		if (this->sparse) {
HXLINE( 202)			return true;
            		}
            		else {
HXLINE( 203)			if ((len == 255)) {
HXLINE( 204)				return false;
            			}
            			else {
HXLINE( 205)				if ((len > 10)) {
HXLINE( 206)					return true;
            				}
            				else {
HXLINE( 208)					return false;
            				}
            			}
            		}
HXLINE( 200)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Codebook_obj,includeInSort,return )

bool Codebook_obj::computeCodewords(::Array< int > len,int n,::Array< int > values){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_214_computeCodewords)
HXLINE( 215)		::Array< int > this1 = ::Array_obj< int >::__new(32);
HXDLIN( 215)		::Array< int > available = this1;
HXLINE( 216)		{
HXLINE( 216)			available->__unsafe_set(0,0);
HXDLIN( 216)			available->__unsafe_set(1,0);
HXDLIN( 216)			available->__unsafe_set(2,0);
HXDLIN( 216)			available->__unsafe_set(3,0);
HXDLIN( 216)			available->__unsafe_set(4,0);
HXDLIN( 216)			available->__unsafe_set(5,0);
HXDLIN( 216)			available->__unsafe_set(6,0);
HXDLIN( 216)			available->__unsafe_set(7,0);
HXDLIN( 216)			available->__unsafe_set(8,0);
HXDLIN( 216)			available->__unsafe_set(9,0);
HXDLIN( 216)			available->__unsafe_set(10,0);
HXDLIN( 216)			available->__unsafe_set(11,0);
HXDLIN( 216)			available->__unsafe_set(12,0);
HXDLIN( 216)			available->__unsafe_set(13,0);
HXDLIN( 216)			available->__unsafe_set(14,0);
HXDLIN( 216)			available->__unsafe_set(15,0);
HXDLIN( 216)			available->__unsafe_set(16,0);
HXDLIN( 216)			available->__unsafe_set(17,0);
HXDLIN( 216)			available->__unsafe_set(18,0);
HXDLIN( 216)			available->__unsafe_set(19,0);
HXDLIN( 216)			available->__unsafe_set(20,0);
HXDLIN( 216)			available->__unsafe_set(21,0);
HXDLIN( 216)			available->__unsafe_set(22,0);
HXDLIN( 216)			available->__unsafe_set(23,0);
HXDLIN( 216)			available->__unsafe_set(24,0);
HXDLIN( 216)			available->__unsafe_set(25,0);
HXDLIN( 216)			available->__unsafe_set(26,0);
HXDLIN( 216)			available->__unsafe_set(27,0);
HXDLIN( 216)			available->__unsafe_set(28,0);
HXDLIN( 216)			available->__unsafe_set(29,0);
HXDLIN( 216)			available->__unsafe_set(30,0);
HXDLIN( 216)			available->__unsafe_set(31,0);
            		}
HXLINE( 219)		int k = 0;
HXLINE( 220)		while((k < n)){
HXLINE( 221)			if ((( (int)(_hx_array_unsafe_get(len,k)) ) < 255)) {
HXLINE( 222)				goto _hx_goto_3;
            			}
HXLINE( 224)			k = (k + 1);
            		}
            		_hx_goto_3:;
HXLINE( 227)		if ((k == n)) {
HXLINE( 229)			return true;
            		}
HXLINE( 232)		int m = 0;
HXLINE( 235)		{
HXLINE( 235)			m = (m + 1);
HXDLIN( 235)			int count = (m - 1);
HXDLIN( 235)			int len1 = ( (int)(_hx_array_unsafe_get(len,k)) );
HXDLIN( 235)			if (!(this->sparse)) {
HXLINE( 235)				this->codewords->__unsafe_set(k,0);
            			}
            			else {
HXLINE( 235)				this->codewords->__unsafe_set(count,0);
HXDLIN( 235)				this->codewordLengths->__unsafe_set(count,len1);
HXDLIN( 235)				values->__unsafe_set(count,k);
            			}
            		}
HXLINE( 238)		int i = 0;
HXLINE( 240)		while(true){
HXLINE( 240)			i = (i + 1);
HXDLIN( 240)			if (!((i <= ( (int)(_hx_array_unsafe_get(len,k)) )))) {
HXLINE( 240)				goto _hx_goto_4;
            			}
HXLINE( 241)			available->__unsafe_set(i,(1 << (32 - i)));
            		}
            		_hx_goto_4:;
HXLINE( 248)		i = k;
HXLINE( 249)		while(true){
HXLINE( 249)			i = (i + 1);
HXDLIN( 249)			if (!((i < n))) {
HXLINE( 249)				goto _hx_goto_5;
            			}
HXLINE( 250)			int z = ( (int)(_hx_array_unsafe_get(len,i)) );
HXLINE( 251)			if ((z == 255)) {
HXLINE( 251)				continue;
            			}
HXLINE( 259)			while(true){
HXLINE( 259)				bool _hx_tmp;
HXDLIN( 259)				if ((z > 0)) {
HXLINE( 259)					_hx_tmp = (( (int)(_hx_array_unsafe_get(available,z)) ) == 0);
            				}
            				else {
HXLINE( 259)					_hx_tmp = false;
            				}
HXDLIN( 259)				if (!(_hx_tmp)) {
HXLINE( 259)					goto _hx_goto_6;
            				}
HXDLIN( 259)				z = (z - 1);
            			}
            			_hx_goto_6:;
HXLINE( 260)			if ((z == 0)) {
HXLINE( 261)				return false;
            			}
HXLINE( 264)			int res = ( (int)(_hx_array_unsafe_get(available,z)) );
HXLINE( 265)			available->__unsafe_set(z,0);
HXLINE( 266)			{
HXLINE( 266)				int n1 = res;
HXDLIN( 266)				n1 = (::hx::UShr((n1 & (int)-1431655766),1) | ((n1 & (int)1431655765) << 1));
HXDLIN( 266)				n1 = (::hx::UShr((n1 & -858993460),2) | ((n1 & 858993459) << 2));
HXDLIN( 266)				n1 = (::hx::UShr((n1 & -252645136),4) | ((n1 & 252645135) << 4));
HXDLIN( 266)				n1 = (::hx::UShr((n1 & -16711936),8) | ((n1 & 16711935) << 8));
HXDLIN( 266)				int huffCode = (::hx::UShr(n1,16) | (n1 << 16));
HXDLIN( 266)				m = (m + 1);
HXDLIN( 266)				int count = (m - 1);
HXDLIN( 266)				int len1 = ( (int)(_hx_array_unsafe_get(len,i)) );
HXDLIN( 266)				if (!(this->sparse)) {
HXLINE( 266)					this->codewords->__unsafe_set(i,huffCode);
            				}
            				else {
HXLINE( 266)					this->codewords->__unsafe_set(count,huffCode);
HXDLIN( 266)					this->codewordLengths->__unsafe_set(count,len1);
HXDLIN( 266)					values->__unsafe_set(count,i);
            				}
            			}
HXLINE( 269)			if ((z != ( (int)(_hx_array_unsafe_get(len,i)) ))) {
HXLINE( 270)				int y = ( (int)(_hx_array_unsafe_get(len,i)) );
HXLINE( 271)				while((y > z)){
HXLINE( 272)					bool b = (( (int)(_hx_array_unsafe_get(available,y)) ) == 0);
HXLINE( 273)					available->__unsafe_set(y,(res + (1 << (32 - y))));
HXLINE( 274)					y = (y - 1);
            				}
            			}
            		}
            		_hx_goto_5:;
HXLINE( 279)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Codebook_obj,computeCodewords,return )

void Codebook_obj::computeSortedHuffman(::Array< int > lengths,::Array< int > values){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_284_computeSortedHuffman)
HXLINE( 289)		if (!(this->sparse)) {
HXLINE( 290)			int k = 0;
HXLINE( 291)			{
HXLINE( 291)				int _g = 0;
HXDLIN( 291)				int _g1 = this->entries;
HXDLIN( 291)				while((_g < _g1)){
HXLINE( 291)					_g = (_g + 1);
HXDLIN( 291)					int i = (_g - 1);
HXLINE( 292)					int len = ( (int)(_hx_array_unsafe_get(lengths,i)) );
HXDLIN( 292)					bool _hx_tmp;
HXDLIN( 292)					if (this->sparse) {
HXLINE( 292)						_hx_tmp = true;
            					}
            					else {
HXLINE( 292)						if ((len == 255)) {
HXLINE( 292)							_hx_tmp = false;
            						}
            						else {
HXLINE( 292)							if ((len > 10)) {
HXLINE( 292)								_hx_tmp = true;
            							}
            							else {
HXLINE( 292)								_hx_tmp = false;
            							}
            						}
            					}
HXDLIN( 292)					if (_hx_tmp) {
HXLINE( 293)						::Array< int > _hx_tmp = this->sortedCodewords;
HXDLIN( 293)						k = (k + 1);
HXDLIN( 293)						int n = ( (int)(_hx_array_unsafe_get(this->codewords,i)) );
HXDLIN( 293)						n = (::hx::UShr((n & (int)-1431655766),1) | ((n & (int)1431655765) << 1));
HXDLIN( 293)						n = (::hx::UShr((n & -858993460),2) | ((n & 858993459) << 2));
HXDLIN( 293)						n = (::hx::UShr((n & -252645136),4) | ((n & 252645135) << 4));
HXDLIN( 293)						n = (::hx::UShr((n & -16711936),8) | ((n & 16711935) << 8));
HXDLIN( 293)						_hx_tmp[(k - 1)] = (::hx::UShr(n,16) | (n << 16));
            					}
            				}
            			}
            		}
            		else {
HXLINE( 298)			int _g = 0;
HXDLIN( 298)			int _g1 = this->sortedEntries;
HXDLIN( 298)			while((_g < _g1)){
HXLINE( 298)				_g = (_g + 1);
HXDLIN( 298)				int i = (_g - 1);
HXLINE( 299)				::Array< int > _hx_tmp = this->sortedCodewords;
HXDLIN( 299)				int n = ( (int)(_hx_array_unsafe_get(this->codewords,i)) );
HXDLIN( 299)				n = (::hx::UShr((n & (int)-1431655766),1) | ((n & (int)1431655765) << 1));
HXDLIN( 299)				n = (::hx::UShr((n & -858993460),2) | ((n & 858993459) << 2));
HXDLIN( 299)				n = (::hx::UShr((n & -252645136),4) | ((n & 252645135) << 4));
HXDLIN( 299)				n = (::hx::UShr((n & -16711936),8) | ((n & 16711935) << 8));
HXDLIN( 299)				_hx_tmp[i] = (::hx::UShr(n,16) | (n << 16));
            			}
            		}
HXLINE( 303)		this->sortedCodewords[this->sortedEntries] = -1;
HXLINE( 304)		this->sortedCodewords->sort(::kha::audio2::ogg::vorbis::VorbisTools_obj::uintAsc_dyn());
HXLINE( 306)		int len;
HXDLIN( 306)		if (this->sparse) {
HXLINE( 306)			len = this->sortedEntries;
            		}
            		else {
HXLINE( 306)			len = this->entries;
            		}
HXLINE( 312)		{
HXLINE( 312)			int _g = 0;
HXDLIN( 312)			int _g1 = len;
HXDLIN( 312)			while((_g < _g1)){
HXLINE( 312)				_g = (_g + 1);
HXDLIN( 312)				int i = (_g - 1);
HXLINE( 313)				int huffLen;
HXDLIN( 313)				if (this->sparse) {
HXLINE( 313)					huffLen = ( (int)(_hx_array_unsafe_get(lengths,( (int)(_hx_array_unsafe_get(values,i)) ))) );
            				}
            				else {
HXLINE( 313)					huffLen = ( (int)(_hx_array_unsafe_get(lengths,i)) );
            				}
HXLINE( 314)				bool _hx_tmp;
HXDLIN( 314)				if (this->sparse) {
HXLINE( 314)					_hx_tmp = true;
            				}
            				else {
HXLINE( 314)					if ((huffLen == 255)) {
HXLINE( 314)						_hx_tmp = false;
            					}
            					else {
HXLINE( 314)						if ((huffLen > 10)) {
HXLINE( 314)							_hx_tmp = true;
            						}
            						else {
HXLINE( 314)							_hx_tmp = false;
            						}
            					}
            				}
HXDLIN( 314)				if (_hx_tmp) {
HXLINE( 315)					int n = ( (int)(_hx_array_unsafe_get(this->codewords,i)) );
HXDLIN( 315)					n = (::hx::UShr((n & (int)-1431655766),1) | ((n & (int)1431655765) << 1));
HXDLIN( 315)					n = (::hx::UShr((n & -858993460),2) | ((n & 858993459) << 2));
HXDLIN( 315)					n = (::hx::UShr((n & -252645136),4) | ((n & 252645135) << 4));
HXDLIN( 315)					n = (::hx::UShr((n & -16711936),8) | ((n & 16711935) << 8));
HXDLIN( 315)					int code = (::hx::UShr(n,16) | (n << 16));
HXLINE( 316)					int x = 0;
HXLINE( 317)					int n1 = this->sortedEntries;
HXLINE( 318)					while((n1 > 1)){
HXLINE( 320)						int m = (x + (n1 >> 1));
HXLINE( 321)						int a = this->sortedCodewords->__get(m);
HXDLIN( 321)						bool aNeg = (code < 0);
HXDLIN( 321)						bool bNeg = (a < 0);
HXDLIN( 321)						bool _hx_tmp;
HXDLIN( 321)						if ((aNeg != bNeg)) {
HXLINE( 321)							_hx_tmp = aNeg;
            						}
            						else {
HXLINE( 321)							_hx_tmp = (code >= a);
            						}
HXDLIN( 321)						if (_hx_tmp) {
HXLINE( 322)							x = m;
HXLINE( 323)							n1 = (n1 - (n1 >> 1));
            						}
            						else {
HXLINE( 325)							n1 = (n1 >> 1);
            						}
            					}
HXLINE( 330)					if (this->sparse) {
HXLINE( 331)						{
HXLINE( 331)							::Array< int > this1 = this->sortedValues;
HXDLIN( 331)							int val = ( (int)(_hx_array_unsafe_get(values,i)) );
HXDLIN( 331)							this1->__unsafe_set(x,val);
            						}
HXLINE( 332)						this->codewordLengths->__unsafe_set(x,huffLen);
            					}
            					else {
HXLINE( 334)						this->sortedValues->__unsafe_set(x,i);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Codebook_obj,computeSortedHuffman,(void))

void Codebook_obj::computeAcceleratedHuffman(){
            	HX_GC_STACKFRAME(&_hx_pos_0f8046c382d51ee6_341_computeAcceleratedHuffman)
HXLINE( 342)		::Array< int > this1 = ::Array_obj< int >::__new(1024);
HXDLIN( 342)		this->_hx_set_fastHuffman(HX_CTX, this1);
HXLINE( 343)		this->fastHuffman->__unsafe_set(0,-1);
HXLINE( 344)		{
HXLINE( 344)			int _g = 0;
HXDLIN( 344)			int _g1 = 1024;
HXDLIN( 344)			while((_g < _g1)){
HXLINE( 344)				_g = (_g + 1);
HXDLIN( 344)				int i = (_g - 1);
HXLINE( 345)				this->fastHuffman->__unsafe_set(i,-1);
            			}
            		}
HXLINE( 348)		int len;
HXDLIN( 348)		if (this->sparse) {
HXLINE( 348)			len = this->sortedEntries;
            		}
            		else {
HXLINE( 348)			len = this->entries;
            		}
HXLINE( 353)		{
HXLINE( 353)			int _g2 = 0;
HXDLIN( 353)			int _g3 = len;
HXDLIN( 353)			while((_g2 < _g3)){
HXLINE( 353)				_g2 = (_g2 + 1);
HXDLIN( 353)				int i = (_g2 - 1);
HXLINE( 354)				if (::hx::IsLessEq( _hx_array_unsafe_get(this->codewordLengths,i),10 )) {
HXLINE( 355)					int z;
HXDLIN( 355)					if (this->sparse) {
HXLINE( 355)						int n = this->sortedCodewords->__get(i);
HXDLIN( 355)						n = (::hx::UShr((n & (int)-1431655766),1) | ((n & (int)1431655765) << 1));
HXDLIN( 355)						n = (::hx::UShr((n & -858993460),2) | ((n & 858993459) << 2));
HXDLIN( 355)						n = (::hx::UShr((n & -252645136),4) | ((n & 252645135) << 4));
HXDLIN( 355)						n = (::hx::UShr((n & -16711936),8) | ((n & 16711935) << 8));
HXDLIN( 355)						z = (::hx::UShr(n,16) | (n << 16));
            					}
            					else {
HXLINE( 355)						z = ( (int)(_hx_array_unsafe_get(this->codewords,i)) );
            					}
HXLINE( 357)					while((z < 1024)){
HXLINE( 358)						this->fastHuffman->__unsafe_set(z,i);
HXLINE( 359)						z = (z + (1 << ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) )));
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Codebook_obj,computeAcceleratedHuffman,(void))

bool Codebook_obj::codebookDecode( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState,::Array< Float > output,int offset,int len){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_367_codebookDecode)
HXLINE( 368)		if ((decodeState->validBits < 10)) {
HXLINE( 368)			decodeState->prepHuffman();
            		}
HXDLIN( 368)		int i = ( (int)(_hx_array_unsafe_get(this->fastHuffman,(decodeState->acc & 1023))) );
HXDLIN( 368)		int val;
HXDLIN( 368)		if ((i >= 0)) {
HXLINE( 368)			int l = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 368)			decodeState->acc = ::hx::UShr(decodeState->acc,l);
HXDLIN( 368)			 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 368)			decodeState1->validBits = (decodeState1->validBits - l);
HXDLIN( 368)			if ((decodeState->validBits < 0)) {
HXLINE( 368)				decodeState->validBits = 0;
HXDLIN( 368)				val = -1;
            			}
            			else {
HXLINE( 368)				val = i;
            			}
            		}
            		else {
HXLINE( 368)			val = decodeState->decodeScalarRaw(::hx::ObjectPtr<OBJ_>(this));
            		}
HXDLIN( 368)		if (this->sparse) {
HXLINE( 368)			val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            		}
HXDLIN( 368)		int z = val;
HXLINE( 369)		int lookupValues = this->lookupValues;
HXLINE( 370)		bool sequenceP = this->sequenceP;
HXLINE( 371)		::Array< Float > multiplicands = this->multiplicands;
HXLINE( 372)		Float minimumValue = this->minimumValue;
HXLINE( 374)		if ((z < 0)) {
HXLINE( 375)			return false;
            		}
HXLINE( 377)		if ((len > this->dimensions)) {
HXLINE( 378)			len = this->dimensions;
            		}
HXLINE( 382)		if ((this->lookupType == 1)) {
HXLINE( 383)			int div = 1;
HXLINE( 384)			Float last = ((Float)0.0);
HXLINE( 385)			{
HXLINE( 385)				int _g = 0;
HXDLIN( 385)				int _g1 = len;
HXDLIN( 385)				while((_g < _g1)){
HXLINE( 385)					_g = (_g + 1);
HXDLIN( 385)					int i = (_g - 1);
HXLINE( 386)					int _hx_int = ::Std_obj::_hx_int((( (Float)(z) ) / ( (Float)(div) )));
HXDLIN( 386)					Float off;
HXDLIN( 386)					if ((_hx_int < 0)) {
HXLINE( 386)						off = (((Float)4294967296.0) + _hx_int);
            					}
            					else {
HXLINE( 386)						off = (_hx_int + ((Float)0.0));
            					}
HXDLIN( 386)					int int1 = lookupValues;
HXDLIN( 386)					Float off1;
HXDLIN( 386)					if ((int1 < 0)) {
HXLINE( 386)						off1 = (((Float)4294967296.0) + int1);
            					}
            					else {
HXLINE( 386)						off1 = (int1 + ((Float)0.0));
            					}
HXDLIN( 386)					int off2 = ::Std_obj::_hx_int(::hx::Mod(off,off1));
HXLINE( 387)					Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,off2)) ) + last);
HXLINE( 388)					{
HXLINE( 388)						int _g1 = (offset + i);
HXDLIN( 388)						::Array< Float > _g2 = output;
HXDLIN( 388)						{
HXLINE( 388)							Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 388)							_g2->__unsafe_set(_g1,val1);
            						}
            					}
HXLINE( 389)					if (sequenceP) {
HXLINE( 390)						last = (val + minimumValue);
            					}
HXLINE( 392)					div = (div * lookupValues);
            				}
            			}
HXLINE( 394)			return true;
            		}
HXLINE( 397)		z = (z * this->dimensions);
HXLINE( 398)		if (sequenceP) {
HXLINE( 399)			Float last = ((Float)0.0);
HXLINE( 400)			{
HXLINE( 400)				int _g = 0;
HXDLIN( 400)				int _g1 = len;
HXDLIN( 400)				while((_g < _g1)){
HXLINE( 400)					_g = (_g + 1);
HXDLIN( 400)					int i = (_g - 1);
HXLINE( 401)					Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,(z + i))) ) + last);
HXLINE( 402)					{
HXLINE( 402)						int _g1 = (offset + i);
HXDLIN( 402)						::Array< Float > _g2 = output;
HXDLIN( 402)						{
HXLINE( 402)							Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 402)							_g2->__unsafe_set(_g1,val1);
            						}
            					}
HXLINE( 403)					last = (val + minimumValue);
            				}
            			}
            		}
            		else {
HXLINE( 406)			Float last = ((Float)0.0);
HXLINE( 407)			{
HXLINE( 407)				int _g = 0;
HXDLIN( 407)				int _g1 = len;
HXDLIN( 407)				while((_g < _g1)){
HXLINE( 407)					_g = (_g + 1);
HXDLIN( 407)					int i = (_g - 1);
HXLINE( 408)					{
HXLINE( 408)						int _g1 = (offset + i);
HXDLIN( 408)						::Array< Float > _g2 = output;
HXDLIN( 408)						{
HXLINE( 408)							Float val = ( (Float)(_hx_array_unsafe_get(_g2,_g1)) );
HXDLIN( 408)							Float val1 = (val + (( (Float)(_hx_array_unsafe_get(multiplicands,(z + i))) ) + last));
HXDLIN( 408)							_g2->__unsafe_set(_g1,val1);
            						}
            					}
            				}
            			}
            		}
HXLINE( 411)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Codebook_obj,codebookDecode,return )

bool Codebook_obj::codebookDecodeStep( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState,::Array< Float > output,int offset,int len,int step){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_415_codebookDecodeStep)
HXLINE( 416)		if ((decodeState->validBits < 10)) {
HXLINE( 416)			decodeState->prepHuffman();
            		}
HXDLIN( 416)		int i = ( (int)(_hx_array_unsafe_get(this->fastHuffman,(decodeState->acc & 1023))) );
HXDLIN( 416)		int val;
HXDLIN( 416)		if ((i >= 0)) {
HXLINE( 416)			int l = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 416)			decodeState->acc = ::hx::UShr(decodeState->acc,l);
HXDLIN( 416)			 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 416)			decodeState1->validBits = (decodeState1->validBits - l);
HXDLIN( 416)			if ((decodeState->validBits < 0)) {
HXLINE( 416)				decodeState->validBits = 0;
HXDLIN( 416)				val = -1;
            			}
            			else {
HXLINE( 416)				val = i;
            			}
            		}
            		else {
HXLINE( 416)			val = decodeState->decodeScalarRaw(::hx::ObjectPtr<OBJ_>(this));
            		}
HXDLIN( 416)		if (this->sparse) {
HXLINE( 416)			val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            		}
HXDLIN( 416)		int z = val;
HXLINE( 417)		Float last = ((Float)0.0);
HXLINE( 418)		if ((z < 0)) {
HXLINE( 419)			return false;
            		}
HXLINE( 421)		if ((len > this->dimensions)) {
HXLINE( 422)			len = this->dimensions;
            		}
HXLINE( 425)		int lookupValues = this->lookupValues;
HXLINE( 426)		bool sequenceP = this->sequenceP;
HXLINE( 427)		::Array< Float > multiplicands = this->multiplicands;
HXLINE( 431)		if ((this->lookupType == 1)) {
HXLINE( 432)			int div = 1;
HXLINE( 433)			{
HXLINE( 433)				int _g = 0;
HXDLIN( 433)				int _g1 = len;
HXDLIN( 433)				while((_g < _g1)){
HXLINE( 433)					_g = (_g + 1);
HXDLIN( 433)					int i = (_g - 1);
HXLINE( 434)					int _hx_int = ::Std_obj::_hx_int((( (Float)(z) ) / ( (Float)(div) )));
HXDLIN( 434)					Float off;
HXDLIN( 434)					if ((_hx_int < 0)) {
HXLINE( 434)						off = (((Float)4294967296.0) + _hx_int);
            					}
            					else {
HXLINE( 434)						off = (_hx_int + ((Float)0.0));
            					}
HXDLIN( 434)					int int1 = lookupValues;
HXDLIN( 434)					Float off1;
HXDLIN( 434)					if ((int1 < 0)) {
HXLINE( 434)						off1 = (((Float)4294967296.0) + int1);
            					}
            					else {
HXLINE( 434)						off1 = (int1 + ((Float)0.0));
            					}
HXDLIN( 434)					int off2 = ::Std_obj::_hx_int(::hx::Mod(off,off1));
HXLINE( 435)					Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,off2)) ) + last);
HXLINE( 436)					{
HXLINE( 436)						int _g1 = (offset + (i * step));
HXDLIN( 436)						::Array< Float > _g2 = output;
HXDLIN( 436)						{
HXLINE( 436)							Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 436)							_g2->__unsafe_set(_g1,val1);
            						}
            					}
HXLINE( 437)					if (sequenceP) {
HXLINE( 438)						last = val;
            					}
HXLINE( 440)					div = (div * lookupValues);
            				}
            			}
HXLINE( 442)			return true;
            		}
HXLINE( 445)		z = (z * this->dimensions);
HXLINE( 446)		{
HXLINE( 446)			int _g = 0;
HXDLIN( 446)			int _g1 = len;
HXDLIN( 446)			while((_g < _g1)){
HXLINE( 446)				_g = (_g + 1);
HXDLIN( 446)				int i = (_g - 1);
HXLINE( 447)				Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,(z + i))) ) + last);
HXLINE( 448)				{
HXLINE( 448)					int _g1 = (offset + (i * step));
HXDLIN( 448)					::Array< Float > _g2 = output;
HXDLIN( 448)					{
HXLINE( 448)						Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 448)						_g2->__unsafe_set(_g1,val1);
            					}
            				}
HXLINE( 449)				if (sequenceP) {
HXLINE( 450)					last = val;
            				}
            			}
            		}
HXLINE( 454)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC5(Codebook_obj,codebookDecodeStep,return )

int Codebook_obj::decodeStart( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_459_decodeStart)
HXDLIN( 459)		if ((decodeState->validBits < 10)) {
HXDLIN( 459)			decodeState->prepHuffman();
            		}
HXDLIN( 459)		int i = ( (int)(_hx_array_unsafe_get(this->fastHuffman,(decodeState->acc & 1023))) );
HXDLIN( 459)		int val;
HXDLIN( 459)		if ((i >= 0)) {
HXDLIN( 459)			int l = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 459)			decodeState->acc = ::hx::UShr(decodeState->acc,l);
HXDLIN( 459)			 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 459)			decodeState1->validBits = (decodeState1->validBits - l);
HXDLIN( 459)			if ((decodeState->validBits < 0)) {
HXDLIN( 459)				decodeState->validBits = 0;
HXDLIN( 459)				val = -1;
            			}
            			else {
HXDLIN( 459)				val = i;
            			}
            		}
            		else {
HXDLIN( 459)			val = decodeState->decodeScalarRaw(::hx::ObjectPtr<OBJ_>(this));
            		}
HXDLIN( 459)		if (this->sparse) {
HXDLIN( 459)			val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            		}
HXDLIN( 459)		return val;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Codebook_obj,decodeStart,return )

 ::Dynamic Codebook_obj::decodeDeinterleaveRepeat( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState,::Array< ::Dynamic> residueBuffers,int ch,int cInter,int pInter,int len,int totalDecode){
            	HX_GC_STACKFRAME(&_hx_pos_0f8046c382d51ee6_483_decodeDeinterleaveRepeat)
HXLINE( 484)		int effective = this->dimensions;
HXLINE( 487)		if ((this->lookupType == 0)) {
HXLINE( 488)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_STREAM_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Codebook.hx",77,0d,3d,a0),488,HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee),HX_("decodeDeinterleaveRepeat",65,00,32,3c)))));
            		}
HXLINE( 491)		::Array< Float > multiplicands = this->multiplicands;
HXLINE( 492)		bool sequenceP = this->sequenceP;
HXLINE( 493)		int lookupValues = this->lookupValues;
HXLINE( 495)		while((totalDecode > 0)){
HXLINE( 496)			Float last = ((Float)0.0);
HXLINE( 497)			if ((decodeState->validBits < 10)) {
HXLINE( 497)				decodeState->prepHuffman();
            			}
HXDLIN( 497)			int i = ( (int)(_hx_array_unsafe_get(this->fastHuffman,(decodeState->acc & 1023))) );
HXDLIN( 497)			int val;
HXDLIN( 497)			if ((i >= 0)) {
HXLINE( 497)				int l = ( (int)(_hx_array_unsafe_get(this->codewordLengths,i)) );
HXDLIN( 497)				decodeState->acc = ::hx::UShr(decodeState->acc,l);
HXDLIN( 497)				 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 497)				decodeState1->validBits = (decodeState1->validBits - l);
HXDLIN( 497)				if ((decodeState->validBits < 0)) {
HXLINE( 497)					decodeState->validBits = 0;
HXDLIN( 497)					val = -1;
            				}
            				else {
HXLINE( 497)					val = i;
            				}
            			}
            			else {
HXLINE( 497)				val = decodeState->decodeScalarRaw(::hx::ObjectPtr<OBJ_>(this));
            			}
HXDLIN( 497)			if (this->sparse) {
HXLINE( 497)				val = ( (int)(_hx_array_unsafe_get(this->sortedValues,val)) );
            			}
HXDLIN( 497)			int z = val;
HXLINE( 499)			if ((z < 0)) {
HXLINE( 500)				bool _hx_tmp;
HXDLIN( 500)				if ((decodeState->bytesInSeg == 0)) {
HXLINE( 500)					_hx_tmp = decodeState->lastSeg;
            				}
            				else {
HXLINE( 500)					_hx_tmp = false;
            				}
HXDLIN( 500)				if (_hx_tmp) {
HXLINE( 501)					return null();
            				}
HXLINE( 503)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_STREAM_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Codebook.hx",77,0d,3d,a0),503,HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee),HX_("decodeDeinterleaveRepeat",65,00,32,3c)))));
            			}
HXLINE( 510)			if ((((cInter + (pInter * ch)) + effective) > (len * ch))) {
HXLINE( 511)				effective = ((len * ch) - ((pInter * ch) - cInter));
            			}
HXLINE( 514)			if ((this->lookupType == 1)) {
HXLINE( 515)				int div = 1;
HXLINE( 516)				if (sequenceP) {
HXLINE( 517)					int _g = 0;
HXDLIN( 517)					int _g1 = effective;
HXDLIN( 517)					while((_g < _g1)){
HXLINE( 517)						_g = (_g + 1);
HXDLIN( 517)						int i = (_g - 1);
HXLINE( 518)						int _hx_int = ::Std_obj::_hx_int((( (Float)(z) ) / ( (Float)(div) )));
HXDLIN( 518)						Float off;
HXDLIN( 518)						if ((_hx_int < 0)) {
HXLINE( 518)							off = (((Float)4294967296.0) + _hx_int);
            						}
            						else {
HXLINE( 518)							off = (_hx_int + ((Float)0.0));
            						}
HXDLIN( 518)						int int1 = lookupValues;
HXDLIN( 518)						Float off1;
HXDLIN( 518)						if ((int1 < 0)) {
HXLINE( 518)							off1 = (((Float)4294967296.0) + int1);
            						}
            						else {
HXLINE( 518)							off1 = (int1 + ((Float)0.0));
            						}
HXDLIN( 518)						int off2 = ::Std_obj::_hx_int(::hx::Mod(off,off1));
HXLINE( 519)						Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,off2)) ) + last);
HXLINE( 520)						{
HXLINE( 520)							int _g1 = pInter;
HXDLIN( 520)							::Array< Float > _g2 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 520)							{
HXLINE( 520)								Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 520)								_g2->__unsafe_set(_g1,val1);
            							}
            						}
HXLINE( 521)						cInter = (cInter + 1);
HXDLIN( 521)						if ((cInter == ch)) {
HXLINE( 522)							cInter = 0;
HXLINE( 523)							pInter = (pInter + 1);
            						}
HXLINE( 525)						last = val;
HXLINE( 526)						div = (div * lookupValues);
            					}
            				}
            				else {
HXLINE( 529)					int _g = 0;
HXDLIN( 529)					int _g1 = effective;
HXDLIN( 529)					while((_g < _g1)){
HXLINE( 529)						_g = (_g + 1);
HXDLIN( 529)						int i = (_g - 1);
HXLINE( 530)						int _hx_int = ::Std_obj::_hx_int((( (Float)(z) ) / ( (Float)(div) )));
HXDLIN( 530)						Float off;
HXDLIN( 530)						if ((_hx_int < 0)) {
HXLINE( 530)							off = (((Float)4294967296.0) + _hx_int);
            						}
            						else {
HXLINE( 530)							off = (_hx_int + ((Float)0.0));
            						}
HXDLIN( 530)						int int1 = lookupValues;
HXDLIN( 530)						Float off1;
HXDLIN( 530)						if ((int1 < 0)) {
HXLINE( 530)							off1 = (((Float)4294967296.0) + int1);
            						}
            						else {
HXLINE( 530)							off1 = (int1 + ((Float)0.0));
            						}
HXDLIN( 530)						int off2 = ::Std_obj::_hx_int(::hx::Mod(off,off1));
HXLINE( 531)						Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,off2)) ) + last);
HXLINE( 532)						{
HXLINE( 532)							int _g1 = pInter;
HXDLIN( 532)							::Array< Float > _g2 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 532)							{
HXLINE( 532)								Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 532)								_g2->__unsafe_set(_g1,val1);
            							}
            						}
HXLINE( 533)						cInter = (cInter + 1);
HXDLIN( 533)						if ((cInter == ch)) {
HXLINE( 534)							cInter = 0;
HXLINE( 535)							pInter = (pInter + 1);
            						}
HXLINE( 537)						div = (div * lookupValues);
            					}
            				}
            			}
            			else {
HXLINE( 541)				z = (z * this->dimensions);
HXLINE( 542)				if (sequenceP) {
HXLINE( 543)					int _g = 0;
HXDLIN( 543)					int _g1 = effective;
HXDLIN( 543)					while((_g < _g1)){
HXLINE( 543)						_g = (_g + 1);
HXDLIN( 543)						int i = (_g - 1);
HXLINE( 544)						Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,(z + i))) ) + last);
HXLINE( 545)						{
HXLINE( 545)							int _g1 = pInter;
HXDLIN( 545)							::Array< Float > _g2 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 545)							{
HXLINE( 545)								Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 545)								_g2->__unsafe_set(_g1,val1);
            							}
            						}
HXLINE( 546)						cInter = (cInter + 1);
HXDLIN( 546)						if ((cInter == ch)) {
HXLINE( 547)							cInter = 0;
HXLINE( 548)							pInter = (pInter + 1);
            						}
HXLINE( 550)						last = val;
            					}
            				}
            				else {
HXLINE( 553)					int _g = 0;
HXDLIN( 553)					int _g1 = effective;
HXDLIN( 553)					while((_g < _g1)){
HXLINE( 553)						_g = (_g + 1);
HXDLIN( 553)						int i = (_g - 1);
HXLINE( 554)						Float val = (( (Float)(_hx_array_unsafe_get(multiplicands,(z + i))) ) + last);
HXLINE( 555)						{
HXLINE( 555)							int _g1 = pInter;
HXDLIN( 555)							::Array< Float > _g2 = ( (::Array< Float >)(_hx_array_unsafe_get(residueBuffers,cInter)) );
HXDLIN( 555)							{
HXLINE( 555)								Float val1 = (( (Float)(_hx_array_unsafe_get(_g2,_g1)) ) + val);
HXDLIN( 555)								_g2->__unsafe_set(_g1,val1);
            							}
            						}
HXLINE( 556)						cInter = (cInter + 1);
HXDLIN( 556)						if ((cInter == ch)) {
HXLINE( 557)							cInter = 0;
HXLINE( 558)							pInter = (pInter + 1);
            						}
            					}
            				}
            			}
HXLINE( 564)			totalDecode = (totalDecode - effective);
            		}
HXLINE( 567)		return  ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("cInter",b9,e7,a2,e6),cInter)
            			->setFixed(1,HX_("pInter",8c,98,46,19),pInter));
            	}


HX_DEFINE_DYNAMIC_FUNC7(Codebook_obj,decodeDeinterleaveRepeat,return )

bool Codebook_obj::residueDecode( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState,::Array< Float > target,int offset,int n,int rtype){
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_574_residueDecode)
HXLINE( 575)		if ((rtype == 0)) {
HXLINE( 576)			int step = ::Std_obj::_hx_int((( (Float)(n) ) / ( (Float)(this->dimensions) )));
HXLINE( 577)			{
HXLINE( 577)				int _g = 0;
HXDLIN( 577)				int _g1 = step;
HXDLIN( 577)				while((_g < _g1)){
HXLINE( 577)					_g = (_g + 1);
HXDLIN( 577)					int k = (_g - 1);
HXLINE( 578)					if (!(this->codebookDecodeStep(decodeState,target,(offset + k),((n - offset) - k),step))) {
HXLINE( 579)						return false;
            					}
            				}
            			}
            		}
            		else {
HXLINE( 583)			int k = 0;
HXLINE( 584)			while((k < n)){
HXLINE( 585)				if (!(this->codebookDecode(decodeState,target,offset,(n - k)))) {
HXLINE( 586)					return false;
            				}
HXLINE( 588)				k = (k + this->dimensions);
HXLINE( 589)				offset = (offset + this->dimensions);
            			}
            		}
HXLINE( 592)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC5(Codebook_obj,residueDecode,return )

int Codebook_obj::NO_CODE;

 ::kha::audio2::ogg::vorbis::data::Codebook Codebook_obj::read( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState){
            	HX_GC_STACKFRAME(&_hx_pos_0f8046c382d51ee6_37_read)
HXLINE(  38)		 ::kha::audio2::ogg::vorbis::data::Codebook c =  ::kha::audio2::ogg::vorbis::data::Codebook_obj::__alloc( HX_CTX );
HXLINE(  39)		bool _hx_tmp;
HXDLIN(  39)		bool _hx_tmp1;
HXDLIN(  39)		if ((decodeState->readBits(8) == 66)) {
HXLINE(  39)			_hx_tmp1 = (decodeState->readBits(8) != 67);
            		}
            		else {
HXLINE(  39)			_hx_tmp1 = true;
            		}
HXDLIN(  39)		if (!(_hx_tmp1)) {
HXLINE(  39)			_hx_tmp = (decodeState->readBits(8) != 86);
            		}
            		else {
HXLINE(  39)			_hx_tmp = true;
            		}
HXDLIN(  39)		if (_hx_tmp) {
HXLINE(  40)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Codebook.hx",77,0d,3d,a0),40,HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  43)		int x = decodeState->readBits(8);
HXLINE(  44)		c->dimensions = ((decodeState->readBits(8) << 8) + x);
HXLINE(  46)		int x1 = decodeState->readBits(8);
HXLINE(  47)		int y = decodeState->readBits(8);
HXLINE(  48)		c->entries = (((decodeState->readBits(8) << 16) + (y << 8)) + x1);
HXLINE(  49)		int ordered = decodeState->readBits(1);
HXLINE(  50)		bool _hx_tmp2;
HXDLIN(  50)		if ((ordered != 0)) {
HXLINE(  50)			_hx_tmp2 = false;
            		}
            		else {
HXLINE(  50)			_hx_tmp2 = (decodeState->readBits(1) != 0);
            		}
HXDLIN(  50)		c->sparse = _hx_tmp2;
HXLINE(  52)		::Array< int > this1 = ::Array_obj< int >::__new(c->entries);
HXDLIN(  52)		::Array< int > lengths = this1;
HXLINE(  53)		if (!(c->sparse)) {
HXLINE(  54)			c->_hx_set_codewordLengths(HX_CTX, lengths);
            		}
HXLINE(  57)		int total = 0;
HXLINE(  59)		if ((ordered != 0)) {
HXLINE(  60)			int currentEntry = 0;
HXLINE(  61)			int currentLength = (decodeState->readBits(5) + 1);
HXLINE(  63)			while((currentEntry < c->entries)){
HXLINE(  64)				int limit = (c->entries - currentEntry);
HXLINE(  65)				::Array< int > log2_4 = ::Array_obj< int >::fromData( _hx_array_data_ee7b42a6_43,16);
HXDLIN(  65)				int n;
HXDLIN(  65)				if ((limit < 16384)) {
HXLINE(  65)					if ((limit < 16)) {
HXLINE(  65)						n = log2_4->__get(limit);
            					}
            					else {
HXLINE(  65)						if ((limit < 512)) {
HXLINE(  65)							n = (5 + log2_4->__get((limit >> 5)));
            						}
            						else {
HXLINE(  65)							n = (10 + log2_4->__get((limit >> 10)));
            						}
            					}
            				}
            				else {
HXLINE(  65)					if ((limit < 16777216)) {
HXLINE(  65)						if ((limit < 524288)) {
HXLINE(  65)							n = (15 + log2_4->__get((limit >> 15)));
            						}
            						else {
HXLINE(  65)							n = (20 + log2_4->__get((limit >> 20)));
            						}
            					}
            					else {
HXLINE(  65)						if ((limit < 536870912)) {
HXLINE(  65)							n = (25 + log2_4->__get((limit >> 25)));
            						}
            						else {
HXLINE(  65)							if ((limit < (int)-2147483648)) {
HXLINE(  65)								n = (30 + log2_4->__get((limit >> 30)));
            							}
            							else {
HXLINE(  65)								n = 0;
            							}
            						}
            					}
            				}
HXDLIN(  65)				int n1 = decodeState->readBits(n);
HXLINE(  66)				if (((currentEntry + n1) > c->entries)) {
HXLINE(  67)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("codebook entrys",cb,3a,30,82),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Codebook.hx",77,0d,3d,a0),67,HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee),HX_("read",56,4b,a7,4b)))));
            				}
HXLINE(  69)				{
HXLINE(  69)					int _g = 0;
HXDLIN(  69)					int _g1 = n1;
HXDLIN(  69)					while((_g < _g1)){
HXLINE(  69)						_g = (_g + 1);
HXDLIN(  69)						int i = (_g - 1);
HXLINE(  70)						lengths->__unsafe_set((currentEntry + i),currentLength);
            					}
            				}
HXLINE(  72)				currentEntry = (currentEntry + n1);
HXLINE(  73)				currentLength = (currentLength + 1);
            			}
            		}
            		else {
HXLINE(  76)			int _g = 0;
HXDLIN(  76)			int _g1 = c->entries;
HXDLIN(  76)			while((_g < _g1)){
HXLINE(  76)				_g = (_g + 1);
HXDLIN(  76)				int j = (_g - 1);
HXLINE(  77)				int present;
HXDLIN(  77)				if (c->sparse) {
HXLINE(  77)					present = decodeState->readBits(1);
            				}
            				else {
HXLINE(  77)					present = 1;
            				}
HXLINE(  78)				if ((present != 0)) {
HXLINE(  79)					{
HXLINE(  79)						int val = (decodeState->readBits(5) + 1);
HXDLIN(  79)						lengths->__unsafe_set(j,val);
            					}
HXLINE(  80)					total = (total + 1);
            				}
            				else {
HXLINE(  82)					lengths->__unsafe_set(j,255);
            				}
            			}
            		}
HXLINE(  87)		bool _hx_tmp3;
HXDLIN(  87)		if (c->sparse) {
HXLINE(  87)			_hx_tmp3 = (total >= (c->entries >> 2));
            		}
            		else {
HXLINE(  87)			_hx_tmp3 = false;
            		}
HXDLIN(  87)		if (_hx_tmp3) {
HXLINE(  88)			c->_hx_set_codewordLengths(HX_CTX, lengths);
HXLINE(  89)			c->sparse = false;
            		}
HXLINE(  92)		int _hx_tmp4;
HXDLIN(  92)		if (c->sparse) {
HXLINE(  92)			_hx_tmp4 = total;
            		}
            		else {
HXLINE(  95)			int sortedCount = 0;
HXLINE(  96)			{
HXLINE(  96)				int _g = 0;
HXDLIN(  96)				int _g1 = c->entries;
HXDLIN(  96)				while((_g < _g1)){
HXLINE(  96)					_g = (_g + 1);
HXDLIN(  96)					int j = (_g - 1);
HXLINE(  97)					int l = ( (int)(_hx_array_unsafe_get(lengths,j)) );
HXLINE(  98)					bool _hx_tmp;
HXDLIN(  98)					if ((l > 10)) {
HXLINE(  98)						_hx_tmp = (l != 255);
            					}
            					else {
HXLINE(  98)						_hx_tmp = false;
            					}
HXDLIN(  98)					if (_hx_tmp) {
HXLINE(  99)						sortedCount = (sortedCount + 1);
            					}
            				}
            			}
HXLINE(  92)			_hx_tmp4 = sortedCount;
            		}
HXDLIN(  92)		c->sortedEntries = _hx_tmp4;
HXLINE( 105)		::Array< int > values = null();
HXLINE( 107)		if (!(c->sparse)) {
HXLINE( 108)			::Array< int > this1 = ::Array_obj< int >::__new(c->entries);
HXDLIN( 108)			c->_hx_set_codewords(HX_CTX, this1);
            		}
            		else {
HXLINE( 110)			if ((c->sortedEntries != 0)) {
HXLINE( 111)				::Array< int > this1 = ::Array_obj< int >::__new(c->sortedEntries);
HXDLIN( 111)				c->_hx_set_codewordLengths(HX_CTX, this1);
HXLINE( 112)				::Array< int > this2 = ::Array_obj< int >::__new(c->entries);
HXDLIN( 112)				c->_hx_set_codewords(HX_CTX, this2);
HXLINE( 113)				::Array< int > this3 = ::Array_obj< int >::__new(c->entries);
HXDLIN( 113)				values = this3;
            			}
HXLINE( 116)			int size = (c->entries + (64 * c->sortedEntries));
            		}
HXLINE( 119)		if (!(c->computeCodewords(lengths,c->entries,values))) {
HXLINE( 120)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("compute codewords",33,59,f7,f8),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Codebook.hx",77,0d,3d,a0),120,HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE( 123)		if ((c->sortedEntries != 0)) {
HXLINE( 125)			c->_hx_set_sortedCodewords(HX_CTX, ::Array_obj< int >::__new(0));
HXLINE( 129)			::Array< int > this1 = ::Array_obj< int >::__new(c->sortedEntries);
HXDLIN( 129)			c->_hx_set_sortedValues(HX_CTX, this1);
HXLINE( 130)			c->computeSortedHuffman(lengths,values);
            		}
HXLINE( 133)		if (c->sparse) {
HXLINE( 134)			values = null();
HXLINE( 135)			c->_hx_set_codewords(HX_CTX, null());
HXLINE( 136)			lengths = null();
            		}
HXLINE( 139)		c->computeAcceleratedHuffman();
HXLINE( 141)		c->lookupType = decodeState->readBits(4);
HXLINE( 142)		if ((c->lookupType > 2)) {
HXLINE( 143)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("codebook lookup type",d6,92,ea,e4),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Codebook.hx",77,0d,3d,a0),143,HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE( 146)		if ((c->lookupType > 0)) {
HXLINE( 147)			int x = decodeState->readBits(32);
HXDLIN( 147)			Float mantissa;
HXDLIN( 147)			int _hx_int = (x & 2097151);
HXDLIN( 147)			if ((_hx_int < 0)) {
HXLINE( 147)				mantissa = (((Float)4294967296.0) + _hx_int);
            			}
            			else {
HXLINE( 147)				mantissa = (_hx_int + ((Float)0.0));
            			}
HXDLIN( 147)			int sign = (x & (int)-2147483648);
HXDLIN( 147)			int exp = ::hx::UShr((x & (int)2145386496),21);
HXDLIN( 147)			Float res;
HXDLIN( 147)			if ((sign != 0)) {
HXLINE( 147)				res = -(mantissa);
            			}
            			else {
HXLINE( 147)				res = mantissa;
            			}
HXDLIN( 147)			c->minimumValue = (res * ::Math_obj::pow(( (Float)(2) ),( (Float)((exp - 788)) )));
HXLINE( 148)			int x1 = decodeState->readBits(32);
HXDLIN( 148)			Float mantissa1;
HXDLIN( 148)			int int1 = (x1 & 2097151);
HXDLIN( 148)			if ((int1 < 0)) {
HXLINE( 148)				mantissa1 = (((Float)4294967296.0) + int1);
            			}
            			else {
HXLINE( 148)				mantissa1 = (int1 + ((Float)0.0));
            			}
HXDLIN( 148)			int sign1 = (x1 & (int)-2147483648);
HXDLIN( 148)			int exp1 = ::hx::UShr((x1 & (int)2145386496),21);
HXDLIN( 148)			Float res1;
HXDLIN( 148)			if ((sign1 != 0)) {
HXLINE( 148)				res1 = -(mantissa1);
            			}
            			else {
HXLINE( 148)				res1 = mantissa1;
            			}
HXDLIN( 148)			c->deltaValue = (res1 * ::Math_obj::pow(( (Float)(2) ),( (Float)((exp1 - 788)) )));
HXLINE( 149)			c->valueBits = (decodeState->readBits(4) + 1);
HXLINE( 150)			c->sequenceP = (decodeState->readBits(1) != 0);
HXLINE( 152)			if ((c->lookupType == 1)) {
HXLINE( 153)				c->lookupValues = ::kha::audio2::ogg::vorbis::VorbisTools_obj::lookup1Values(c->entries,c->dimensions);
            			}
            			else {
HXLINE( 155)				c->lookupValues = (c->entries * c->dimensions);
            			}
HXLINE( 157)			::Array< int > this1 = ::Array_obj< int >::__new(c->lookupValues);
HXDLIN( 157)			::Array< int > mults = this1;
HXLINE( 158)			{
HXLINE( 158)				int _g = 0;
HXDLIN( 158)				int _g1 = c->lookupValues;
HXDLIN( 158)				while((_g < _g1)){
HXLINE( 158)					_g = (_g + 1);
HXDLIN( 158)					int j = (_g - 1);
HXLINE( 159)					int q = decodeState->readBits(c->valueBits);
HXLINE( 160)					if ((q == -1)) {
HXLINE( 161)						HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("fail lookup",7c,d8,86,6f),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Codebook.hx",77,0d,3d,a0),161,HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee),HX_("read",56,4b,a7,4b)))));
            					}
HXLINE( 163)					mults->__unsafe_set(j,q);
            				}
            			}
HXLINE( 166)			{
HXLINE( 167)				::Array< Float > this2 = ::Array_obj< Float >::__new(c->lookupValues);
HXDLIN( 167)				c->_hx_set_multiplicands(HX_CTX, this2);
HXLINE( 170)				{
HXLINE( 170)					int _g2 = 0;
HXDLIN( 170)					int _g3 = c->lookupValues;
HXDLIN( 170)					while((_g2 < _g3)){
HXLINE( 170)						_g2 = (_g2 + 1);
HXDLIN( 170)						int j = (_g2 - 1);
HXLINE( 171)						{
HXLINE( 171)							::Array< Float > this1 = c->multiplicands;
HXDLIN( 171)							Float val = (( (Float)(( (int)(_hx_array_unsafe_get(mults,j)) )) ) * c->deltaValue);
HXDLIN( 171)							this1->__unsafe_set(j,(val + c->minimumValue));
            						}
            					}
            				}
            			}
HXLINE( 176)			bool _hx_tmp;
HXDLIN( 176)			if ((c->lookupType == 2)) {
HXLINE( 176)				_hx_tmp = c->sequenceP;
            			}
            			else {
HXLINE( 176)				_hx_tmp = false;
            			}
HXDLIN( 176)			if (_hx_tmp) {
HXLINE( 177)				{
HXLINE( 177)					int _g = 1;
HXDLIN( 177)					int _g1 = c->lookupValues;
HXDLIN( 177)					while((_g < _g1)){
HXLINE( 177)						_g = (_g + 1);
HXDLIN( 177)						int j = (_g - 1);
HXLINE( 178)						{
HXLINE( 178)							::Array< Float > this1 = c->multiplicands;
HXDLIN( 178)							Float val = ( (Float)(_hx_array_unsafe_get(c->multiplicands,(j - 1))) );
HXDLIN( 178)							this1->__unsafe_set(j,val);
            						}
            					}
            				}
HXLINE( 180)				c->sequenceP = false;
            			}
            		}
HXLINE( 184)		return c;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Codebook_obj,read,return )

int Codebook_obj::delay;


::hx::ObjectPtr< Codebook_obj > Codebook_obj::__new() {
	::hx::ObjectPtr< Codebook_obj > __this = new Codebook_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Codebook_obj > Codebook_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Codebook_obj *__this = (Codebook_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Codebook_obj), true, "kha.audio2.ogg.vorbis.data.Codebook"));
	*(void **)__this = Codebook_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Codebook_obj::Codebook_obj()
{
}

void Codebook_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Codebook);
	HX_MARK_MEMBER_NAME(dimensions,"dimensions");
	HX_MARK_MEMBER_NAME(entries,"entries");
	HX_MARK_MEMBER_NAME(codewordLengths,"codewordLengths");
	HX_MARK_MEMBER_NAME(minimumValue,"minimumValue");
	HX_MARK_MEMBER_NAME(deltaValue,"deltaValue");
	HX_MARK_MEMBER_NAME(valueBits,"valueBits");
	HX_MARK_MEMBER_NAME(lookupType,"lookupType");
	HX_MARK_MEMBER_NAME(sequenceP,"sequenceP");
	HX_MARK_MEMBER_NAME(sparse,"sparse");
	HX_MARK_MEMBER_NAME(lookupValues,"lookupValues");
	HX_MARK_MEMBER_NAME(multiplicands,"multiplicands");
	HX_MARK_MEMBER_NAME(codewords,"codewords");
	HX_MARK_MEMBER_NAME(fastHuffman,"fastHuffman");
	HX_MARK_MEMBER_NAME(sortedCodewords,"sortedCodewords");
	HX_MARK_MEMBER_NAME(sortedValues,"sortedValues");
	HX_MARK_MEMBER_NAME(sortedEntries,"sortedEntries");
	HX_MARK_END_CLASS();
}

void Codebook_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(dimensions,"dimensions");
	HX_VISIT_MEMBER_NAME(entries,"entries");
	HX_VISIT_MEMBER_NAME(codewordLengths,"codewordLengths");
	HX_VISIT_MEMBER_NAME(minimumValue,"minimumValue");
	HX_VISIT_MEMBER_NAME(deltaValue,"deltaValue");
	HX_VISIT_MEMBER_NAME(valueBits,"valueBits");
	HX_VISIT_MEMBER_NAME(lookupType,"lookupType");
	HX_VISIT_MEMBER_NAME(sequenceP,"sequenceP");
	HX_VISIT_MEMBER_NAME(sparse,"sparse");
	HX_VISIT_MEMBER_NAME(lookupValues,"lookupValues");
	HX_VISIT_MEMBER_NAME(multiplicands,"multiplicands");
	HX_VISIT_MEMBER_NAME(codewords,"codewords");
	HX_VISIT_MEMBER_NAME(fastHuffman,"fastHuffman");
	HX_VISIT_MEMBER_NAME(sortedCodewords,"sortedCodewords");
	HX_VISIT_MEMBER_NAME(sortedValues,"sortedValues");
	HX_VISIT_MEMBER_NAME(sortedEntries,"sortedEntries");
}

::hx::Val Codebook_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"sparse") ) { return ::hx::Val( sparse ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"entries") ) { return ::hx::Val( entries ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"addEntry") ) { return ::hx::Val( addEntry_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"valueBits") ) { return ::hx::Val( valueBits ); }
		if (HX_FIELD_EQ(inName,"sequenceP") ) { return ::hx::Val( sequenceP ); }
		if (HX_FIELD_EQ(inName,"codewords") ) { return ::hx::Val( codewords ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"dimensions") ) { return ::hx::Val( dimensions ); }
		if (HX_FIELD_EQ(inName,"deltaValue") ) { return ::hx::Val( deltaValue ); }
		if (HX_FIELD_EQ(inName,"lookupType") ) { return ::hx::Val( lookupType ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"fastHuffman") ) { return ::hx::Val( fastHuffman ); }
		if (HX_FIELD_EQ(inName,"decodeStart") ) { return ::hx::Val( decodeStart_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"minimumValue") ) { return ::hx::Val( minimumValue ); }
		if (HX_FIELD_EQ(inName,"lookupValues") ) { return ::hx::Val( lookupValues ); }
		if (HX_FIELD_EQ(inName,"sortedValues") ) { return ::hx::Val( sortedValues ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"multiplicands") ) { return ::hx::Val( multiplicands ); }
		if (HX_FIELD_EQ(inName,"sortedEntries") ) { return ::hx::Val( sortedEntries ); }
		if (HX_FIELD_EQ(inName,"includeInSort") ) { return ::hx::Val( includeInSort_dyn() ); }
		if (HX_FIELD_EQ(inName,"residueDecode") ) { return ::hx::Val( residueDecode_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"codebookDecode") ) { return ::hx::Val( codebookDecode_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"codewordLengths") ) { return ::hx::Val( codewordLengths ); }
		if (HX_FIELD_EQ(inName,"sortedCodewords") ) { return ::hx::Val( sortedCodewords ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"computeCodewords") ) { return ::hx::Val( computeCodewords_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"codebookDecodeStep") ) { return ::hx::Val( codebookDecodeStep_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"computeSortedHuffman") ) { return ::hx::Val( computeSortedHuffman_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"decodeDeinterleaveRepeat") ) { return ::hx::Val( decodeDeinterleaveRepeat_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"computeAcceleratedHuffman") ) { return ::hx::Val( computeAcceleratedHuffman_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Codebook_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { outValue = read_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { outValue = ( delay ); return true; }
	}
	return false;
}

::hx::Val Codebook_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"sparse") ) { sparse=inValue.Cast< bool >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"entries") ) { entries=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"valueBits") ) { valueBits=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sequenceP") ) { sequenceP=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"codewords") ) { _hx_set_codewords(HX_CTX_GET,inValue.Cast< ::Array< int > >()); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"dimensions") ) { dimensions=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"deltaValue") ) { deltaValue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lookupType") ) { lookupType=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"fastHuffman") ) { _hx_set_fastHuffman(HX_CTX_GET,inValue.Cast< ::Array< int > >()); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"minimumValue") ) { minimumValue=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lookupValues") ) { lookupValues=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sortedValues") ) { _hx_set_sortedValues(HX_CTX_GET,inValue.Cast< ::Array< int > >()); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"multiplicands") ) { _hx_set_multiplicands(HX_CTX_GET,inValue.Cast< ::Array< Float > >()); return inValue; }
		if (HX_FIELD_EQ(inName,"sortedEntries") ) { sortedEntries=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"codewordLengths") ) { _hx_set_codewordLengths(HX_CTX_GET,inValue.Cast< ::Array< int > >()); return inValue; }
		if (HX_FIELD_EQ(inName,"sortedCodewords") ) { _hx_set_sortedCodewords(HX_CTX_GET,inValue.Cast< ::Array< int > >()); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Codebook_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { delay=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Codebook_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("dimensions",4d,be,9f,dc));
	outFields->push(HX_("entries",50,2d,5f,79));
	outFields->push(HX_("codewordLengths",16,3c,fc,19));
	outFields->push(HX_("minimumValue",c3,5e,55,b4));
	outFields->push(HX_("deltaValue",59,24,db,dc));
	outFields->push(HX_("valueBits",17,b3,9b,8d));
	outFields->push(HX_("lookupType",54,86,f3,40));
	outFields->push(HX_("sequenceP",ef,5a,8d,e6));
	outFields->push(HX_("sparse",e0,0e,60,b8));
	outFields->push(HX_("lookupValues",fc,31,21,02));
	outFields->push(HX_("multiplicands",0b,05,c0,91));
	outFields->push(HX_("codewords",1c,7b,0d,cf));
	outFields->push(HX_("fastHuffman",f1,9f,8c,5a));
	outFields->push(HX_("sortedCodewords",1f,f8,5c,96));
	outFields->push(HX_("sortedValues",ff,96,90,f3));
	outFields->push(HX_("sortedEntries",93,53,e6,33));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Codebook_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Codebook_obj,dimensions),HX_("dimensions",4d,be,9f,dc)},
	{::hx::fsInt,(int)offsetof(Codebook_obj,entries),HX_("entries",50,2d,5f,79)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Codebook_obj,codewordLengths),HX_("codewordLengths",16,3c,fc,19)},
	{::hx::fsFloat,(int)offsetof(Codebook_obj,minimumValue),HX_("minimumValue",c3,5e,55,b4)},
	{::hx::fsFloat,(int)offsetof(Codebook_obj,deltaValue),HX_("deltaValue",59,24,db,dc)},
	{::hx::fsInt,(int)offsetof(Codebook_obj,valueBits),HX_("valueBits",17,b3,9b,8d)},
	{::hx::fsInt,(int)offsetof(Codebook_obj,lookupType),HX_("lookupType",54,86,f3,40)},
	{::hx::fsBool,(int)offsetof(Codebook_obj,sequenceP),HX_("sequenceP",ef,5a,8d,e6)},
	{::hx::fsBool,(int)offsetof(Codebook_obj,sparse),HX_("sparse",e0,0e,60,b8)},
	{::hx::fsInt,(int)offsetof(Codebook_obj,lookupValues),HX_("lookupValues",fc,31,21,02)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Codebook_obj,multiplicands),HX_("multiplicands",0b,05,c0,91)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Codebook_obj,codewords),HX_("codewords",1c,7b,0d,cf)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Codebook_obj,fastHuffman),HX_("fastHuffman",f1,9f,8c,5a)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Codebook_obj,sortedCodewords),HX_("sortedCodewords",1f,f8,5c,96)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Codebook_obj,sortedValues),HX_("sortedValues",ff,96,90,f3)},
	{::hx::fsInt,(int)offsetof(Codebook_obj,sortedEntries),HX_("sortedEntries",93,53,e6,33)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Codebook_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &Codebook_obj::NO_CODE,HX_("NO_CODE",2b,45,52,21)},
	{::hx::fsInt,(void *) &Codebook_obj::delay,HX_("delay",83,d7,26,d7)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Codebook_obj_sMemberFields[] = {
	HX_("dimensions",4d,be,9f,dc),
	HX_("entries",50,2d,5f,79),
	HX_("codewordLengths",16,3c,fc,19),
	HX_("minimumValue",c3,5e,55,b4),
	HX_("deltaValue",59,24,db,dc),
	HX_("valueBits",17,b3,9b,8d),
	HX_("lookupType",54,86,f3,40),
	HX_("sequenceP",ef,5a,8d,e6),
	HX_("sparse",e0,0e,60,b8),
	HX_("lookupValues",fc,31,21,02),
	HX_("multiplicands",0b,05,c0,91),
	HX_("codewords",1c,7b,0d,cf),
	HX_("fastHuffman",f1,9f,8c,5a),
	HX_("sortedCodewords",1f,f8,5c,96),
	HX_("sortedValues",ff,96,90,f3),
	HX_("sortedEntries",93,53,e6,33),
	HX_("addEntry",91,9e,e3,e9),
	HX_("includeInSort",2b,86,f6,b6),
	HX_("computeCodewords",a5,ec,44,c8),
	HX_("computeSortedHuffman",79,ff,c7,ef),
	HX_("computeAcceleratedHuffman",5d,4a,6a,c6),
	HX_("codebookDecode",a4,25,0d,e9),
	HX_("codebookDecodeStep",10,db,ef,6b),
	HX_("decodeStart",54,00,25,4c),
	HX_("decodeDeinterleaveRepeat",65,00,32,3c),
	HX_("residueDecode",d9,53,88,4e),
	::String(null()) };

static void Codebook_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Codebook_obj::NO_CODE,"NO_CODE");
	HX_MARK_MEMBER_NAME(Codebook_obj::delay,"delay");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Codebook_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Codebook_obj::NO_CODE,"NO_CODE");
	HX_VISIT_MEMBER_NAME(Codebook_obj::delay,"delay");
};

#endif

::hx::Class Codebook_obj::__mClass;

static ::String Codebook_obj_sStaticFields[] = {
	HX_("NO_CODE",2b,45,52,21),
	HX_("read",56,4b,a7,4b),
	HX_("delay",83,d7,26,d7),
	::String(null())
};

void Codebook_obj::__register()
{
	Codebook_obj _hx_dummy;
	Codebook_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("kha.audio2.ogg.vorbis.data.Codebook",a6,42,7b,ee);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Codebook_obj::__GetStatic;
	__mClass->mSetStaticField = &Codebook_obj::__SetStatic;
	__mClass->mMarkFunc = Codebook_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Codebook_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Codebook_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Codebook_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Codebook_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Codebook_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Codebook_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Codebook_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_15_boot)
HXDLIN(  15)		NO_CODE = 255;
            	}
{
            	HX_STACKFRAME(&_hx_pos_0f8046c382d51ee6_480_boot)
HXDLIN( 480)		delay = 0;
            	}
}

} // end namespace kha
} // end namespace audio2
} // end namespace ogg
} // end namespace vorbis
} // end namespace data
