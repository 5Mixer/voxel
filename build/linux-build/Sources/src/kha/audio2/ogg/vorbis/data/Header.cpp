// Generated by Haxe 4.1.3
#include <hxcpp.h>

#ifndef INCLUDED_haxe_Exception
#include <hxinc/haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <hxinc/haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_BytesInput
#include <hxinc/haxe/io/BytesInput.h>
#endif
#ifndef INCLUDED_haxe_io_BytesOutput
#include <hxinc/haxe/io/BytesOutput.h>
#endif
#ifndef INCLUDED_haxe_io_Encoding
#include <hxinc/haxe/io/Encoding.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <hxinc/haxe/io/Input.h>
#endif
#ifndef INCLUDED_haxe_io_Output
#include <hxinc/haxe/io/Output.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_VorbisDecodeState
#include <hxinc/kha/audio2/ogg/vorbis/VorbisDecodeState.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Codebook
#include <hxinc/kha/audio2/ogg/vorbis/data/Codebook.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Comment
#include <hxinc/kha/audio2/ogg/vorbis/data/Comment.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Floor
#include <hxinc/kha/audio2/ogg/vorbis/data/Floor.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Header
#include <hxinc/kha/audio2/ogg/vorbis/data/Header.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Mapping
#include <hxinc/kha/audio2/ogg/vorbis/data/Mapping.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Mode
#include <hxinc/kha/audio2/ogg/vorbis/data/Mode.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Page
#include <hxinc/kha/audio2/ogg/vorbis/data/Page.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_ReaderError
#include <hxinc/kha/audio2/ogg/vorbis/data/ReaderError.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_ReaderErrorType
#include <hxinc/kha/audio2/ogg/vorbis/data/ReaderErrorType.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Residue
#include <hxinc/kha/audio2/ogg/vorbis/data/Residue.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5d80631968e67c5f_37_new,"kha.audio2.ogg.vorbis.data.Header","new",0x66f8bbcf,"kha.audio2.ogg.vorbis.data.Header.new","kha/audio2/ogg/vorbis/data/Header.hx",37,0x4e0c5e60)
HX_LOCAL_STACK_FRAME(_hx_pos_5d80631968e67c5f_41_read,"kha.audio2.ogg.vorbis.data.Header","read",0xb5506107,"kha.audio2.ogg.vorbis.data.Header.read","kha/audio2/ogg/vorbis/data/Header.hx",41,0x4e0c5e60)
HX_LOCAL_STACK_FRAME(_hx_pos_5d80631968e67c5f_18_boot,"kha.audio2.ogg.vorbis.data.Header","boot",0xaac499e3,"kha.audio2.ogg.vorbis.data.Header.boot","kha/audio2/ogg/vorbis/data/Header.hx",18,0x4e0c5e60)
HX_LOCAL_STACK_FRAME(_hx_pos_5d80631968e67c5f_19_boot,"kha.audio2.ogg.vorbis.data.Header","boot",0xaac499e3,"kha.audio2.ogg.vorbis.data.Header.boot","kha/audio2/ogg/vorbis/data/Header.hx",19,0x4e0c5e60)
HX_LOCAL_STACK_FRAME(_hx_pos_5d80631968e67c5f_20_boot,"kha.audio2.ogg.vorbis.data.Header","boot",0xaac499e3,"kha.audio2.ogg.vorbis.data.Header.boot","kha/audio2/ogg/vorbis/data/Header.hx",20,0x4e0c5e60)
namespace kha{
namespace audio2{
namespace ogg{
namespace vorbis{
namespace data{

void Header_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_5d80631968e67c5f_37_new)
            	}

Dynamic Header_obj::__CreateEmpty() { return new Header_obj; }

void *Header_obj::_hx_vtable = 0;

Dynamic Header_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Header_obj > _hx_result = new Header_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Header_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x30b5331d;
}

int Header_obj::PACKET_ID;

int Header_obj::PACKET_COMMENT;

int Header_obj::PACKET_SETUP;

 ::kha::audio2::ogg::vorbis::data::Header Header_obj::read( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState){
            	HX_GC_STACKFRAME(&_hx_pos_5d80631968e67c5f_41_read)
HXLINE(  42)		 ::kha::audio2::ogg::vorbis::data::Page page = decodeState->page;
HXLINE(  43)		page->start(decodeState);
HXLINE(  45)		if (((page->flag & 2) == 0)) {
HXLINE(  46)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("not firstPage",52,61,ee,e9),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),46,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  48)		if (((page->flag & 4) != 0)) {
HXLINE(  49)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("lastPage",c5,f3,9a,dd),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),49,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  51)		if (((page->flag & 1) != 0)) {
HXLINE(  52)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("continuedPacket",85,39,ee,94),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),52,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  55)		decodeState->firstPageValidate();
HXLINE(  56)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN(  56)		decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN(  56)		if ((decodeState->input->readByte() != 1)) {
HXLINE(  57)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("decodeState head",5d,8c,63,29),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),57,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  61)		{
HXLINE(  61)			 ::haxe::io::Bytes header = ::haxe::io::Bytes_obj::alloc(6);
HXDLIN(  61)			{
HXLINE(  61)				{
HXLINE(  61)					int x;
HXDLIN(  61)					bool x1;
HXDLIN(  61)					if ((decodeState->bytesInSeg == 0)) {
HXLINE(  61)						if (!(decodeState->lastSeg)) {
HXLINE(  61)							x1 = (decodeState->next() == 0);
            						}
            						else {
HXLINE(  61)							x1 = true;
            						}
            					}
            					else {
HXLINE(  61)						x1 = false;
            					}
HXDLIN(  61)					if (x1) {
HXLINE(  61)						x = -1;
            					}
            					else {
HXLINE(  61)						decodeState->bytesInSeg--;
HXDLIN(  61)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN(  61)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN(  61)						x = decodeState->input->readByte();
            					}
HXDLIN(  61)					decodeState->validBits = 0;
HXDLIN(  61)					header->b[0] = ( (unsigned char)(x) );
            				}
HXDLIN(  61)				{
HXLINE(  61)					int x2;
HXDLIN(  61)					bool x3;
HXDLIN(  61)					if ((decodeState->bytesInSeg == 0)) {
HXLINE(  61)						if (!(decodeState->lastSeg)) {
HXLINE(  61)							x3 = (decodeState->next() == 0);
            						}
            						else {
HXLINE(  61)							x3 = true;
            						}
            					}
            					else {
HXLINE(  61)						x3 = false;
            					}
HXDLIN(  61)					if (x3) {
HXLINE(  61)						x2 = -1;
            					}
            					else {
HXLINE(  61)						decodeState->bytesInSeg--;
HXDLIN(  61)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN(  61)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN(  61)						x2 = decodeState->input->readByte();
            					}
HXDLIN(  61)					decodeState->validBits = 0;
HXDLIN(  61)					header->b[1] = ( (unsigned char)(x2) );
            				}
HXDLIN(  61)				{
HXLINE(  61)					int x4;
HXDLIN(  61)					bool x5;
HXDLIN(  61)					if ((decodeState->bytesInSeg == 0)) {
HXLINE(  61)						if (!(decodeState->lastSeg)) {
HXLINE(  61)							x5 = (decodeState->next() == 0);
            						}
            						else {
HXLINE(  61)							x5 = true;
            						}
            					}
            					else {
HXLINE(  61)						x5 = false;
            					}
HXDLIN(  61)					if (x5) {
HXLINE(  61)						x4 = -1;
            					}
            					else {
HXLINE(  61)						decodeState->bytesInSeg--;
HXDLIN(  61)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN(  61)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN(  61)						x4 = decodeState->input->readByte();
            					}
HXDLIN(  61)					decodeState->validBits = 0;
HXDLIN(  61)					header->b[2] = ( (unsigned char)(x4) );
            				}
HXDLIN(  61)				{
HXLINE(  61)					int x6;
HXDLIN(  61)					bool x7;
HXDLIN(  61)					if ((decodeState->bytesInSeg == 0)) {
HXLINE(  61)						if (!(decodeState->lastSeg)) {
HXLINE(  61)							x7 = (decodeState->next() == 0);
            						}
            						else {
HXLINE(  61)							x7 = true;
            						}
            					}
            					else {
HXLINE(  61)						x7 = false;
            					}
HXDLIN(  61)					if (x7) {
HXLINE(  61)						x6 = -1;
            					}
            					else {
HXLINE(  61)						decodeState->bytesInSeg--;
HXDLIN(  61)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN(  61)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN(  61)						x6 = decodeState->input->readByte();
            					}
HXDLIN(  61)					decodeState->validBits = 0;
HXDLIN(  61)					header->b[3] = ( (unsigned char)(x6) );
            				}
HXDLIN(  61)				{
HXLINE(  61)					int x8;
HXDLIN(  61)					bool x9;
HXDLIN(  61)					if ((decodeState->bytesInSeg == 0)) {
HXLINE(  61)						if (!(decodeState->lastSeg)) {
HXLINE(  61)							x9 = (decodeState->next() == 0);
            						}
            						else {
HXLINE(  61)							x9 = true;
            						}
            					}
            					else {
HXLINE(  61)						x9 = false;
            					}
HXDLIN(  61)					if (x9) {
HXLINE(  61)						x8 = -1;
            					}
            					else {
HXLINE(  61)						decodeState->bytesInSeg--;
HXDLIN(  61)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN(  61)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN(  61)						x8 = decodeState->input->readByte();
            					}
HXDLIN(  61)					decodeState->validBits = 0;
HXDLIN(  61)					header->b[4] = ( (unsigned char)(x8) );
            				}
HXDLIN(  61)				{
HXLINE(  61)					int x10;
HXDLIN(  61)					bool x11;
HXDLIN(  61)					if ((decodeState->bytesInSeg == 0)) {
HXLINE(  61)						if (!(decodeState->lastSeg)) {
HXLINE(  61)							x11 = (decodeState->next() == 0);
            						}
            						else {
HXLINE(  61)							x11 = true;
            						}
            					}
            					else {
HXLINE(  61)						x11 = false;
            					}
HXDLIN(  61)					if (x11) {
HXLINE(  61)						x10 = -1;
            					}
            					else {
HXLINE(  61)						decodeState->bytesInSeg--;
HXDLIN(  61)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN(  61)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN(  61)						x10 = decodeState->input->readByte();
            					}
HXDLIN(  61)					decodeState->validBits = 0;
HXDLIN(  61)					header->b[5] = ( (unsigned char)(x10) );
            				}
            			}
HXDLIN(  61)			if ((header->toString() != HX_("vorbis",53,03,3c,63))) {
HXLINE(  61)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("vorbis header",ba,3e,a4,0e),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/VorbisDecodeState.hx",02,79,2e,1d),301,HX_("kha.audio2.ogg.vorbis.VorbisDecodeState",3c,6b,03,19),HX_("vorbisValidate",09,9b,51,16)))));
            			}
            		}
HXLINE(  64)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState2 = decodeState;
HXDLIN(  64)		decodeState2->inputPosition = (decodeState2->inputPosition + 4);
HXDLIN(  64)		int version = decodeState->input->readInt32();
HXLINE(  65)		if ((version != 0)) {
HXLINE(  66)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),(HX_("vorbis version : ",5b,e2,58,09) + version),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),66,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  69)		 ::kha::audio2::ogg::vorbis::data::Header header1 =  ::kha::audio2::ogg::vorbis::data::Header_obj::__alloc( HX_CTX );
HXLINE(  71)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState3 = decodeState;
HXDLIN(  71)		decodeState3->inputPosition = (decodeState3->inputPosition + 1);
HXDLIN(  71)		header1->channel = decodeState->input->readByte();
HXLINE(  72)		if ((header1->channel == 0)) {
HXLINE(  73)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("no channel",e4,4d,cc,09),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),73,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
            		else {
HXLINE(  74)			if ((header1->channel > 16)) {
HXLINE(  75)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::TOO_MANY_CHANNELS_dyn(),HX_("too many channels",65,2f,80,4b),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),75,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            			}
            		}
HXLINE(  78)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState4 = decodeState;
HXDLIN(  78)		decodeState4->inputPosition = (decodeState4->inputPosition + 4);
HXDLIN(  78)		header1->sampleRate = decodeState->input->readInt32();
HXLINE(  79)		if ((header1->sampleRate == 0)) {
HXLINE(  80)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),HX_("no sampling rate",9a,91,ba,fc),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),80,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  83)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState5 = decodeState;
HXDLIN(  83)		decodeState5->inputPosition = (decodeState5->inputPosition + 4);
HXDLIN(  83)		header1->maximumBitRate = decodeState->input->readInt32();
HXLINE(  84)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState6 = decodeState;
HXDLIN(  84)		decodeState6->inputPosition = (decodeState6->inputPosition + 4);
HXDLIN(  84)		header1->nominalBitRate = decodeState->input->readInt32();
HXLINE(  85)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState7 = decodeState;
HXDLIN(  85)		decodeState7->inputPosition = (decodeState7->inputPosition + 4);
HXDLIN(  85)		header1->minimumBitRate = decodeState->input->readInt32();
HXLINE(  87)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState8 = decodeState;
HXDLIN(  87)		decodeState8->inputPosition = (decodeState8->inputPosition + 1);
HXDLIN(  87)		int x12 = decodeState->input->readByte();
HXLINE(  88)		int log0 = (x12 & 15);
HXLINE(  89)		int log1 = (x12 >> 4);
HXLINE(  90)		header1->blocksize0 = (1 << log0);
HXLINE(  91)		header1->blocksize1 = (1 << log1);
HXLINE(  92)		bool _hx_tmp;
HXDLIN(  92)		if ((log0 >= 6)) {
HXLINE(  92)			_hx_tmp = (log0 > 13);
            		}
            		else {
HXLINE(  92)			_hx_tmp = true;
            		}
HXDLIN(  92)		if (_hx_tmp) {
HXLINE(  93)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),93,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  95)		bool _hx_tmp1;
HXDLIN(  95)		if ((log1 >= 6)) {
HXLINE(  95)			_hx_tmp1 = (log1 > 13);
            		}
            		else {
HXLINE(  95)			_hx_tmp1 = true;
            		}
HXDLIN(  95)		if (_hx_tmp1) {
HXLINE(  96)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),96,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE(  98)		if ((log0 > log1)) {
HXLINE(  99)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),99,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE( 103)		 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState9 = decodeState;
HXDLIN( 103)		decodeState9->inputPosition = (decodeState9->inputPosition + 1);
HXDLIN( 103)		int x13 = decodeState->input->readByte();
HXLINE( 104)		if (((x13 & 1) == 0)) {
HXLINE( 105)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_FIRST_PAGE_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),105,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE( 109)		decodeState->page->start(decodeState);
HXLINE( 110)		decodeState->startPacket();
HXLINE( 112)		int len = 0;
HXLINE( 113)		 ::haxe::io::BytesOutput output =  ::haxe::io::BytesOutput_obj::__alloc( HX_CTX );
HXLINE( 114)		while(true){
HXLINE( 114)			len = decodeState->next();
HXDLIN( 114)			if (!((len != 0))) {
HXLINE( 114)				goto _hx_goto_1;
            			}
HXLINE( 115)			 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 115)			decodeState1->inputPosition = (decodeState1->inputPosition + len);
HXDLIN( 115)			output->write(decodeState->input->read(len));
HXLINE( 116)			decodeState->bytesInSeg = 0;
            		}
            		_hx_goto_1:;
HXLINE( 119)		{
HXLINE( 120)			 ::haxe::io::BytesInput packetInput =  ::haxe::io::BytesInput_obj::__alloc( HX_CTX ,output->getBytes(),null(),null());
HXLINE( 121)			packetInput->readByte();
HXLINE( 122)			packetInput->read(6);
HXLINE( 124)			int vendorLength = packetInput->readInt32();
HXLINE( 125)			header1->_hx_set_vendor(HX_CTX, packetInput->readString(vendorLength,null()));
HXLINE( 126)			header1->_hx_set_comment(HX_CTX,  ::kha::audio2::ogg::vorbis::data::Comment_obj::__alloc( HX_CTX ));
HXLINE( 128)			int commentCount = packetInput->readInt32();
HXLINE( 130)			{
HXLINE( 130)				int _g = 0;
HXDLIN( 130)				int _g1 = commentCount;
HXDLIN( 130)				while((_g < _g1)){
HXLINE( 130)					_g = (_g + 1);
HXDLIN( 130)					int i = (_g - 1);
HXLINE( 131)					int n = packetInput->readInt32();
HXLINE( 132)					::String str = packetInput->readString(n,null());
HXLINE( 133)					int splitter = str.indexOf(HX_("=",3d,00,00,00),null());
HXLINE( 134)					if ((splitter != -1)) {
HXLINE( 135)						 ::kha::audio2::ogg::vorbis::data::Comment header = header1->comment;
HXDLIN( 135)						::String _hx_tmp = str.substring(0,splitter);
HXDLIN( 135)						header->add(_hx_tmp,str.substring((splitter + 1),null()));
            					}
            				}
            			}
HXLINE( 139)			int x14 = packetInput->readByte();
HXLINE( 140)			if (((x14 & 1) == 0)) {
HXLINE( 141)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),141,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            			}
            		}
HXLINE( 146)		decodeState->startPacket();
HXLINE( 148)		int x15;
HXDLIN( 148)		bool x16;
HXDLIN( 148)		if ((decodeState->bytesInSeg == 0)) {
HXLINE( 148)			if (!(decodeState->lastSeg)) {
HXLINE( 148)				x16 = (decodeState->next() == 0);
            			}
            			else {
HXLINE( 148)				x16 = true;
            			}
            		}
            		else {
HXLINE( 148)			x16 = false;
            		}
HXDLIN( 148)		if (x16) {
HXLINE( 148)			x15 = -1;
            		}
            		else {
HXLINE( 148)			decodeState->bytesInSeg--;
HXDLIN( 148)			 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 148)			decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 148)			x15 = decodeState->input->readByte();
            		}
HXDLIN( 148)		decodeState->validBits = 0;
HXDLIN( 148)		if ((x15 != 5)) {
HXLINE( 149)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("setup packet",cb,fa,2a,07),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),149,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            		}
HXLINE( 152)		{
HXLINE( 152)			 ::haxe::io::Bytes header2 = ::haxe::io::Bytes_obj::alloc(6);
HXDLIN( 152)			{
HXLINE( 152)				{
HXLINE( 152)					int x17;
HXDLIN( 152)					bool x18;
HXDLIN( 152)					if ((decodeState->bytesInSeg == 0)) {
HXLINE( 152)						if (!(decodeState->lastSeg)) {
HXLINE( 152)							x18 = (decodeState->next() == 0);
            						}
            						else {
HXLINE( 152)							x18 = true;
            						}
            					}
            					else {
HXLINE( 152)						x18 = false;
            					}
HXDLIN( 152)					if (x18) {
HXLINE( 152)						x17 = -1;
            					}
            					else {
HXLINE( 152)						decodeState->bytesInSeg--;
HXDLIN( 152)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 152)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 152)						x17 = decodeState->input->readByte();
            					}
HXDLIN( 152)					decodeState->validBits = 0;
HXDLIN( 152)					header2->b[0] = ( (unsigned char)(x17) );
            				}
HXDLIN( 152)				{
HXLINE( 152)					int x19;
HXDLIN( 152)					bool x20;
HXDLIN( 152)					if ((decodeState->bytesInSeg == 0)) {
HXLINE( 152)						if (!(decodeState->lastSeg)) {
HXLINE( 152)							x20 = (decodeState->next() == 0);
            						}
            						else {
HXLINE( 152)							x20 = true;
            						}
            					}
            					else {
HXLINE( 152)						x20 = false;
            					}
HXDLIN( 152)					if (x20) {
HXLINE( 152)						x19 = -1;
            					}
            					else {
HXLINE( 152)						decodeState->bytesInSeg--;
HXDLIN( 152)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 152)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 152)						x19 = decodeState->input->readByte();
            					}
HXDLIN( 152)					decodeState->validBits = 0;
HXDLIN( 152)					header2->b[1] = ( (unsigned char)(x19) );
            				}
HXDLIN( 152)				{
HXLINE( 152)					int x21;
HXDLIN( 152)					bool x22;
HXDLIN( 152)					if ((decodeState->bytesInSeg == 0)) {
HXLINE( 152)						if (!(decodeState->lastSeg)) {
HXLINE( 152)							x22 = (decodeState->next() == 0);
            						}
            						else {
HXLINE( 152)							x22 = true;
            						}
            					}
            					else {
HXLINE( 152)						x22 = false;
            					}
HXDLIN( 152)					if (x22) {
HXLINE( 152)						x21 = -1;
            					}
            					else {
HXLINE( 152)						decodeState->bytesInSeg--;
HXDLIN( 152)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 152)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 152)						x21 = decodeState->input->readByte();
            					}
HXDLIN( 152)					decodeState->validBits = 0;
HXDLIN( 152)					header2->b[2] = ( (unsigned char)(x21) );
            				}
HXDLIN( 152)				{
HXLINE( 152)					int x23;
HXDLIN( 152)					bool x24;
HXDLIN( 152)					if ((decodeState->bytesInSeg == 0)) {
HXLINE( 152)						if (!(decodeState->lastSeg)) {
HXLINE( 152)							x24 = (decodeState->next() == 0);
            						}
            						else {
HXLINE( 152)							x24 = true;
            						}
            					}
            					else {
HXLINE( 152)						x24 = false;
            					}
HXDLIN( 152)					if (x24) {
HXLINE( 152)						x23 = -1;
            					}
            					else {
HXLINE( 152)						decodeState->bytesInSeg--;
HXDLIN( 152)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 152)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 152)						x23 = decodeState->input->readByte();
            					}
HXDLIN( 152)					decodeState->validBits = 0;
HXDLIN( 152)					header2->b[3] = ( (unsigned char)(x23) );
            				}
HXDLIN( 152)				{
HXLINE( 152)					int x25;
HXDLIN( 152)					bool x26;
HXDLIN( 152)					if ((decodeState->bytesInSeg == 0)) {
HXLINE( 152)						if (!(decodeState->lastSeg)) {
HXLINE( 152)							x26 = (decodeState->next() == 0);
            						}
            						else {
HXLINE( 152)							x26 = true;
            						}
            					}
            					else {
HXLINE( 152)						x26 = false;
            					}
HXDLIN( 152)					if (x26) {
HXLINE( 152)						x25 = -1;
            					}
            					else {
HXLINE( 152)						decodeState->bytesInSeg--;
HXDLIN( 152)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 152)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 152)						x25 = decodeState->input->readByte();
            					}
HXDLIN( 152)					decodeState->validBits = 0;
HXDLIN( 152)					header2->b[4] = ( (unsigned char)(x25) );
            				}
HXDLIN( 152)				{
HXLINE( 152)					int x27;
HXDLIN( 152)					bool x28;
HXDLIN( 152)					if ((decodeState->bytesInSeg == 0)) {
HXLINE( 152)						if (!(decodeState->lastSeg)) {
HXLINE( 152)							x28 = (decodeState->next() == 0);
            						}
            						else {
HXLINE( 152)							x28 = true;
            						}
            					}
            					else {
HXLINE( 152)						x28 = false;
            					}
HXDLIN( 152)					if (x28) {
HXLINE( 152)						x27 = -1;
            					}
            					else {
HXLINE( 152)						decodeState->bytesInSeg--;
HXDLIN( 152)						 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 152)						decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 152)						x27 = decodeState->input->readByte();
            					}
HXDLIN( 152)					decodeState->validBits = 0;
HXDLIN( 152)					header2->b[5] = ( (unsigned char)(x27) );
            				}
            			}
HXDLIN( 152)			if ((header2->toString() != HX_("vorbis",53,03,3c,63))) {
HXLINE( 152)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),HX_("vorbis header",ba,3e,a4,0e),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/VorbisDecodeState.hx",02,79,2e,1d),301,HX_("kha.audio2.ogg.vorbis.VorbisDecodeState",3c,6b,03,19),HX_("vorbisValidate",09,9b,51,16)))));
            			}
            		}
HXLINE( 155)		int codebookCount = (decodeState->readBits(8) + 1);
HXLINE( 156)		::Array< ::Dynamic> this1 = ::Array_obj< ::Dynamic>::__new(codebookCount);
HXDLIN( 156)		header1->_hx_set_codebooks(HX_CTX, this1);
HXLINE( 157)		{
HXLINE( 157)			int _g2 = 0;
HXDLIN( 157)			int _g3 = codebookCount;
HXDLIN( 157)			while((_g2 < _g3)){
HXLINE( 157)				_g2 = (_g2 + 1);
HXDLIN( 157)				int i = (_g2 - 1);
HXLINE( 158)				{
HXLINE( 158)					::Array< ::Dynamic> this1 = header1->codebooks;
HXDLIN( 158)					 ::kha::audio2::ogg::vorbis::data::Codebook val = ::kha::audio2::ogg::vorbis::data::Codebook_obj::read(decodeState);
HXDLIN( 158)					this1->__unsafe_set(i,val);
            				}
            			}
            		}
HXLINE( 162)		x13 = (decodeState->readBits(6) + 1);
HXLINE( 163)		{
HXLINE( 163)			int _g4 = 0;
HXDLIN( 163)			int _g5 = x13;
HXDLIN( 163)			while((_g4 < _g5)){
HXLINE( 163)				_g4 = (_g4 + 1);
HXDLIN( 163)				int i = (_g4 - 1);
HXLINE( 164)				if ((decodeState->readBits(16) != 0)) {
HXLINE( 165)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),165,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            				}
            			}
            		}
HXLINE( 170)		int floorCount = (decodeState->readBits(6) + 1);
HXLINE( 171)		::Array< ::Dynamic> this2 = ::Array_obj< ::Dynamic>::__new(floorCount);
HXDLIN( 171)		header1->_hx_set_floorConfig(HX_CTX, this2);
HXLINE( 172)		{
HXLINE( 172)			int _g6 = 0;
HXDLIN( 172)			int _g7 = floorCount;
HXDLIN( 172)			while((_g6 < _g7)){
HXLINE( 172)				_g6 = (_g6 + 1);
HXDLIN( 172)				int i = (_g6 - 1);
HXLINE( 173)				{
HXLINE( 173)					::Array< ::Dynamic> this1 = header1->floorConfig;
HXDLIN( 173)					 ::kha::audio2::ogg::vorbis::data::Floor val = ::kha::audio2::ogg::vorbis::data::Floor_obj::read(decodeState,header1->codebooks);
HXDLIN( 173)					this1->__unsafe_set(i,val);
            				}
            			}
            		}
HXLINE( 177)		int residueCount = (decodeState->readBits(6) + 1);
HXLINE( 178)		::Array< ::Dynamic> this3 = ::Array_obj< ::Dynamic>::__new(residueCount);
HXDLIN( 178)		header1->_hx_set_residueConfig(HX_CTX, this3);
HXLINE( 179)		{
HXLINE( 179)			int _g8 = 0;
HXDLIN( 179)			int _g9 = residueCount;
HXDLIN( 179)			while((_g8 < _g9)){
HXLINE( 179)				_g8 = (_g8 + 1);
HXDLIN( 179)				int i = (_g8 - 1);
HXLINE( 180)				{
HXLINE( 180)					::Array< ::Dynamic> this1 = header1->residueConfig;
HXDLIN( 180)					 ::kha::audio2::ogg::vorbis::data::Residue val = ::kha::audio2::ogg::vorbis::data::Residue_obj::read(decodeState,header1->codebooks);
HXDLIN( 180)					this1->__unsafe_set(i,val);
            				}
            			}
            		}
HXLINE( 184)		int mappingCount = (decodeState->readBits(6) + 1);
HXLINE( 185)		::Array< ::Dynamic> this4 = ::Array_obj< ::Dynamic>::__new(mappingCount);
HXDLIN( 185)		header1->_hx_set_mapping(HX_CTX, this4);
HXLINE( 186)		{
HXLINE( 186)			int _g10 = 0;
HXDLIN( 186)			int _g11 = mappingCount;
HXDLIN( 186)			while((_g10 < _g11)){
HXLINE( 186)				_g10 = (_g10 + 1);
HXDLIN( 186)				int i = (_g10 - 1);
HXLINE( 187)				 ::kha::audio2::ogg::vorbis::data::Mapping map = ::kha::audio2::ogg::vorbis::data::Mapping_obj::read(decodeState,header1->channel);
HXLINE( 188)				header1->mapping->__unsafe_set(i,map);
HXLINE( 189)				{
HXLINE( 189)					int _g = 0;
HXDLIN( 189)					int _g1 = map->submaps;
HXDLIN( 189)					while((_g < _g1)){
HXLINE( 189)						_g = (_g + 1);
HXDLIN( 189)						int j = (_g - 1);
HXLINE( 190)						int _hx_tmp = ( (int)(_hx_array_unsafe_get(map->submapFloor,j)) );
HXDLIN( 190)						if ((_hx_tmp >= header1->floorConfig->length)) {
HXLINE( 191)							HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),191,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            						}
HXLINE( 193)						int _hx_tmp1 = ( (int)(_hx_array_unsafe_get(map->submapResidue,j)) );
HXDLIN( 193)						if ((_hx_tmp1 >= header1->residueConfig->length)) {
HXLINE( 194)							HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),194,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            						}
            					}
            				}
            			}
            		}
HXLINE( 199)		int modeCount = (decodeState->readBits(6) + 1);
HXLINE( 200)		::Array< ::Dynamic> this5 = ::Array_obj< ::Dynamic>::__new(modeCount);
HXDLIN( 200)		header1->_hx_set_modes(HX_CTX, this5);
HXLINE( 201)		{
HXLINE( 201)			int _g12 = 0;
HXDLIN( 201)			int _g13 = modeCount;
HXDLIN( 201)			while((_g12 < _g13)){
HXLINE( 201)				_g12 = (_g12 + 1);
HXDLIN( 201)				int i = (_g12 - 1);
HXLINE( 202)				 ::kha::audio2::ogg::vorbis::data::Mode mode = ::kha::audio2::ogg::vorbis::data::Mode_obj::read(decodeState);
HXLINE( 203)				header1->modes->__unsafe_set(i,mode);
HXLINE( 204)				if ((mode->mapping >= header1->mapping->length)) {
HXLINE( 205)					HX_STACK_DO_THROW(::haxe::Exception_obj::thrown( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),::hx::SourceInfo(HX_("kha/audio2/ogg/vorbis/data/Header.hx",60,5e,0c,4e),205,HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae),HX_("read",56,4b,a7,4b)))));
            				}
            			}
            		}
HXLINE( 209)		while(true){
HXLINE( 209)			bool _hx_tmp;
HXDLIN( 209)			if ((decodeState->bytesInSeg == 0)) {
HXLINE( 209)				if (!(decodeState->lastSeg)) {
HXLINE( 209)					_hx_tmp = (decodeState->next() != 0);
            				}
            				else {
HXLINE( 209)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 209)				_hx_tmp = true;
            			}
HXDLIN( 209)			if (!(_hx_tmp)) {
HXLINE( 209)				goto _hx_goto_10;
            			}
HXDLIN( 209)			decodeState->bytesInSeg--;
HXDLIN( 209)			{
HXLINE( 209)				 ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState1 = decodeState;
HXDLIN( 209)				decodeState1->inputPosition = (decodeState1->inputPosition + 1);
HXDLIN( 209)				decodeState->input->readByte();
            			}
            		}
            		_hx_goto_10:;
HXLINE( 211)		return header1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Header_obj,read,return )


Header_obj::Header_obj()
{
}

void Header_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Header);
	HX_MARK_MEMBER_NAME(maximumBitRate,"maximumBitRate");
	HX_MARK_MEMBER_NAME(nominalBitRate,"nominalBitRate");
	HX_MARK_MEMBER_NAME(minimumBitRate,"minimumBitRate");
	HX_MARK_MEMBER_NAME(sampleRate,"sampleRate");
	HX_MARK_MEMBER_NAME(channel,"channel");
	HX_MARK_MEMBER_NAME(blocksize0,"blocksize0");
	HX_MARK_MEMBER_NAME(blocksize1,"blocksize1");
	HX_MARK_MEMBER_NAME(codebooks,"codebooks");
	HX_MARK_MEMBER_NAME(floorConfig,"floorConfig");
	HX_MARK_MEMBER_NAME(residueConfig,"residueConfig");
	HX_MARK_MEMBER_NAME(mapping,"mapping");
	HX_MARK_MEMBER_NAME(modes,"modes");
	HX_MARK_MEMBER_NAME(comment,"comment");
	HX_MARK_MEMBER_NAME(vendor,"vendor");
	HX_MARK_END_CLASS();
}

void Header_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(maximumBitRate,"maximumBitRate");
	HX_VISIT_MEMBER_NAME(nominalBitRate,"nominalBitRate");
	HX_VISIT_MEMBER_NAME(minimumBitRate,"minimumBitRate");
	HX_VISIT_MEMBER_NAME(sampleRate,"sampleRate");
	HX_VISIT_MEMBER_NAME(channel,"channel");
	HX_VISIT_MEMBER_NAME(blocksize0,"blocksize0");
	HX_VISIT_MEMBER_NAME(blocksize1,"blocksize1");
	HX_VISIT_MEMBER_NAME(codebooks,"codebooks");
	HX_VISIT_MEMBER_NAME(floorConfig,"floorConfig");
	HX_VISIT_MEMBER_NAME(residueConfig,"residueConfig");
	HX_VISIT_MEMBER_NAME(mapping,"mapping");
	HX_VISIT_MEMBER_NAME(modes,"modes");
	HX_VISIT_MEMBER_NAME(comment,"comment");
	HX_VISIT_MEMBER_NAME(vendor,"vendor");
}

::hx::Val Header_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"modes") ) { return ::hx::Val( modes ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"vendor") ) { return ::hx::Val( vendor ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"channel") ) { return ::hx::Val( channel ); }
		if (HX_FIELD_EQ(inName,"mapping") ) { return ::hx::Val( mapping ); }
		if (HX_FIELD_EQ(inName,"comment") ) { return ::hx::Val( comment ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"codebooks") ) { return ::hx::Val( codebooks ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sampleRate") ) { return ::hx::Val( sampleRate ); }
		if (HX_FIELD_EQ(inName,"blocksize0") ) { return ::hx::Val( blocksize0 ); }
		if (HX_FIELD_EQ(inName,"blocksize1") ) { return ::hx::Val( blocksize1 ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"floorConfig") ) { return ::hx::Val( floorConfig ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"residueConfig") ) { return ::hx::Val( residueConfig ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"maximumBitRate") ) { return ::hx::Val( maximumBitRate ); }
		if (HX_FIELD_EQ(inName,"nominalBitRate") ) { return ::hx::Val( nominalBitRate ); }
		if (HX_FIELD_EQ(inName,"minimumBitRate") ) { return ::hx::Val( minimumBitRate ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Header_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { outValue = read_dyn(); return true; }
	}
	return false;
}

::hx::Val Header_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"modes") ) { _hx_set_modes(HX_CTX_GET,inValue.Cast< ::Array< ::Dynamic> >()); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"vendor") ) { _hx_set_vendor(HX_CTX_GET,inValue.Cast< ::String >()); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"channel") ) { channel=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mapping") ) { _hx_set_mapping(HX_CTX_GET,inValue.Cast< ::Array< ::Dynamic> >()); return inValue; }
		if (HX_FIELD_EQ(inName,"comment") ) { _hx_set_comment(HX_CTX_GET,inValue.Cast<  ::kha::audio2::ogg::vorbis::data::Comment >()); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"codebooks") ) { _hx_set_codebooks(HX_CTX_GET,inValue.Cast< ::Array< ::Dynamic> >()); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sampleRate") ) { sampleRate=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blocksize0") ) { blocksize0=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blocksize1") ) { blocksize1=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"floorConfig") ) { _hx_set_floorConfig(HX_CTX_GET,inValue.Cast< ::Array< ::Dynamic> >()); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"residueConfig") ) { _hx_set_residueConfig(HX_CTX_GET,inValue.Cast< ::Array< ::Dynamic> >()); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"maximumBitRate") ) { maximumBitRate=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nominalBitRate") ) { nominalBitRate=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"minimumBitRate") ) { minimumBitRate=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Header_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("maximumBitRate",4d,56,30,56));
	outFields->push(HX_("nominalBitRate",91,a2,66,22));
	outFields->push(HX_("minimumBitRate",1f,fa,b9,f2));
	outFields->push(HX_("sampleRate",2a,3c,4c,67));
	outFields->push(HX_("channel",c3,00,d2,cc));
	outFields->push(HX_("blocksize0",e2,3b,0f,c1));
	outFields->push(HX_("blocksize1",e3,3b,0f,c1));
	outFields->push(HX_("codebooks",dd,0b,a1,b7));
	outFields->push(HX_("floorConfig",ae,fd,8a,3c));
	outFields->push(HX_("residueConfig",6d,4d,6d,b1));
	outFields->push(HX_("mapping",0e,7b,7a,44));
	outFields->push(HX_("modes",b0,23,58,0c));
	outFields->push(HX_("comment",5f,7a,70,81));
	outFields->push(HX_("vendor",88,e5,96,9e));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Header_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Header_obj,maximumBitRate),HX_("maximumBitRate",4d,56,30,56)},
	{::hx::fsInt,(int)offsetof(Header_obj,nominalBitRate),HX_("nominalBitRate",91,a2,66,22)},
	{::hx::fsInt,(int)offsetof(Header_obj,minimumBitRate),HX_("minimumBitRate",1f,fa,b9,f2)},
	{::hx::fsInt,(int)offsetof(Header_obj,sampleRate),HX_("sampleRate",2a,3c,4c,67)},
	{::hx::fsInt,(int)offsetof(Header_obj,channel),HX_("channel",c3,00,d2,cc)},
	{::hx::fsInt,(int)offsetof(Header_obj,blocksize0),HX_("blocksize0",e2,3b,0f,c1)},
	{::hx::fsInt,(int)offsetof(Header_obj,blocksize1),HX_("blocksize1",e3,3b,0f,c1)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Header_obj,codebooks),HX_("codebooks",dd,0b,a1,b7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Header_obj,floorConfig),HX_("floorConfig",ae,fd,8a,3c)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Header_obj,residueConfig),HX_("residueConfig",6d,4d,6d,b1)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Header_obj,mapping),HX_("mapping",0e,7b,7a,44)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Header_obj,modes),HX_("modes",b0,23,58,0c)},
	{::hx::fsObject /*  ::kha::audio2::ogg::vorbis::data::Comment */ ,(int)offsetof(Header_obj,comment),HX_("comment",5f,7a,70,81)},
	{::hx::fsString,(int)offsetof(Header_obj,vendor),HX_("vendor",88,e5,96,9e)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Header_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &Header_obj::PACKET_ID,HX_("PACKET_ID",72,37,96,42)},
	{::hx::fsInt,(void *) &Header_obj::PACKET_COMMENT,HX_("PACKET_COMMENT",48,73,92,c8)},
	{::hx::fsInt,(void *) &Header_obj::PACKET_SETUP,HX_("PACKET_SETUP",26,87,2b,68)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Header_obj_sMemberFields[] = {
	HX_("maximumBitRate",4d,56,30,56),
	HX_("nominalBitRate",91,a2,66,22),
	HX_("minimumBitRate",1f,fa,b9,f2),
	HX_("sampleRate",2a,3c,4c,67),
	HX_("channel",c3,00,d2,cc),
	HX_("blocksize0",e2,3b,0f,c1),
	HX_("blocksize1",e3,3b,0f,c1),
	HX_("codebooks",dd,0b,a1,b7),
	HX_("floorConfig",ae,fd,8a,3c),
	HX_("residueConfig",6d,4d,6d,b1),
	HX_("mapping",0e,7b,7a,44),
	HX_("modes",b0,23,58,0c),
	HX_("comment",5f,7a,70,81),
	HX_("vendor",88,e5,96,9e),
	::String(null()) };

static void Header_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Header_obj::PACKET_ID,"PACKET_ID");
	HX_MARK_MEMBER_NAME(Header_obj::PACKET_COMMENT,"PACKET_COMMENT");
	HX_MARK_MEMBER_NAME(Header_obj::PACKET_SETUP,"PACKET_SETUP");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Header_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Header_obj::PACKET_ID,"PACKET_ID");
	HX_VISIT_MEMBER_NAME(Header_obj::PACKET_COMMENT,"PACKET_COMMENT");
	HX_VISIT_MEMBER_NAME(Header_obj::PACKET_SETUP,"PACKET_SETUP");
};

#endif

::hx::Class Header_obj::__mClass;

static ::String Header_obj_sStaticFields[] = {
	HX_("PACKET_ID",72,37,96,42),
	HX_("PACKET_COMMENT",48,73,92,c8),
	HX_("PACKET_SETUP",26,87,2b,68),
	HX_("read",56,4b,a7,4b),
	::String(null())
};

void Header_obj::__register()
{
	Header_obj _hx_dummy;
	Header_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("kha.audio2.ogg.vorbis.data.Header",5d,28,45,ae);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Header_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Header_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Header_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Header_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Header_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Header_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Header_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Header_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Header_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_5d80631968e67c5f_18_boot)
HXDLIN(  18)		PACKET_ID = 1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5d80631968e67c5f_19_boot)
HXDLIN(  19)		PACKET_COMMENT = 3;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5d80631968e67c5f_20_boot)
HXDLIN(  20)		PACKET_SETUP = 5;
            	}
}

} // end namespace kha
} // end namespace audio2
} // end namespace ogg
} // end namespace vorbis
} // end namespace data
